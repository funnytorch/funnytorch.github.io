<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>redis-黑马点评学习 | Torch's blog</title><meta name="author" content="Torch"><meta name="copyright" content="Torch"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基础篇 初识Redis NoSQL NoSql可以翻译做Not Only Sql（不仅仅是SQL），或者是No Sql（非Sql的）数据库。是相对于传统关系型数据库而言，有很大差异的一种特殊的数据库，因此也称之为非关系型数据库。 结构化与非结构化 结构化：传统关系型数据库是结构化数据，每一张表都有严格的约束信息：字段名.字段数据类型.字段约束等等信息，插入的数据必须遵守这些约束。（">
<meta property="og:type" content="article">
<meta property="og:title" content="redis-黑马点评学习">
<meta property="og:url" content="https://funnytorch.github.io/2025/03/12/redis-%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Torch&#39;s blog">
<meta property="og:description" content="基础篇 初识Redis NoSQL NoSql可以翻译做Not Only Sql（不仅仅是SQL），或者是No Sql（非Sql的）数据库。是相对于传统关系型数据库而言，有很大差异的一种特殊的数据库，因此也称之为非关系型数据库。 结构化与非结构化 结构化：传统关系型数据库是结构化数据，每一张表都有严格的约束信息：字段名.字段数据类型.字段约束等等信息，插入的数据必须遵守这些约束。（">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farticle%2F214ebafad407d4879ef439b124f8d375969f7a68.jpg&refer=http%3A%2F%2Fi0.hdslb.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637623496&t=e16f6f4016cd1ecf6cadb59f18d702fe">
<meta property="article:published_time" content="2025-03-12T06:09:45.000Z">
<meta property="article:modified_time" content="2025-04-14T09:16:14.307Z">
<meta property="article:author" content="Torch">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farticle%2F214ebafad407d4879ef439b124f8d375969f7a68.jpg&refer=http%3A%2F%2Fi0.hdslb.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637623496&t=e16f6f4016cd1ecf6cadb59f18d702fe"><link rel="shortcut icon" href="https://pic1.imgdb.cn/item/646c285ce03e90d874adadbd.png"><link rel="canonical" href="https://funnytorch.github.io/2025/03/12/redis-%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E5%AD%A6%E4%B9%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.19/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'redis-黑马点评学习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-04-14 17:16:14'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/modify.css"><link rel="stylesheet" href="https://npm.elemecdn.com/ethan4116-blog/lib/css/plane_v2.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><span id="fps"></span><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://pic1.imgdb.cn/item/646c2881e03e90d874adf7fc.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">75</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">54</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farticle%2F214ebafad407d4879ef439b124f8d375969f7a68.jpg&amp;refer=http%3A%2F%2Fi0.hdslb.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1637623496&amp;t=e16f6f4016cd1ecf6cadb59f18d702fe')"><nav id="nav"><span id="blog-info"><a href="/" title="Torch's blog"><span class="site-name">Torch's blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">redis-黑马点评学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-12T06:09:45.000Z" title="发表于 2025-03-12 14:09:45">2025-03-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-14T09:16:14.307Z" title="更新于 2025-04-14 17:16:14">2025-04-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E5%AD%A6%E4%B9%A0/">Java学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>51分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="redis-黑马点评学习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><meta name="referrer" content="no-referrer" />
<h1 id="基础篇">基础篇</h1>
<h2 id="初识redis">初识Redis</h2>
<h3 id="nosql">NoSQL</h3>
<p><strong>NoSql</strong>可以翻译做Not Only Sql（不仅仅是SQL），或者是No
Sql（非Sql的）数据库。是相对于传统关系型数据库而言，有很大差异的一种特殊的数据库，因此也称之为<strong>非关系型数据库</strong>。</p>
<h4 id="结构化与非结构化">结构化与非结构化</h4>
<p>结构化：传统关系型数据库是结构化数据，每一张表都有严格的约束信息：字段名.字段数据类型.字段约束等等信息，插入的数据必须遵守这些约束。（缺点：表不能随意修改）</p>
<p>非结构化：对数据库格式没有严格约束，往往形式松散，自由。</p>
<ul>
<li>键值型：Redis</li>
<li>文档型（字段约束非常松散）：MongoDB</li>
<li>列类型：HBase</li>
<li>图格式：Neo4j</li>
</ul>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503121420204.png" /></p>
<h4 id="关联与非关联">关联与非关联</h4>
<p>传统数据库的表与表之间往往存在关联，例如外键。</p>
<p>而非关系型数据库不存在关联关系，要维护关系要么靠代码中的业务逻辑，要么靠数据之间的耦合：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  id<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  name<span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">  orders<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">       id<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">       item<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">	 id<span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span> title<span class="punctuation">:</span> <span class="string">&quot;荣耀6&quot;</span><span class="punctuation">,</span> price<span class="punctuation">:</span> <span class="number">4999</span></span><br><span class="line">       <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">       id<span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">       item<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">	 id<span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span> title<span class="punctuation">:</span> <span class="string">&quot;小米11&quot;</span><span class="punctuation">,</span> price<span class="punctuation">:</span> <span class="number">3999</span></span><br><span class="line">       <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>此处要维护“张三”的订单与商品“荣耀”和“小米11”的关系，不得不冗余的将这两个商品保存在张三的订单文档中，不够优雅。还是建议用业务来维护关联关系。</p>
<h4 id="查询方式">查询方式</h4>
<p>传统关系型数据库会基于Sql语句做查询，语法有统一标准；</p>
<p>而不同的非关系数据库查询语法差异极大，五花八门各种各样。</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503121424079.png" /></p>
<h4 id="事务">事务</h4>
<p>传统关系型数据库能满足事务ACID的原则。</p>
<p>而非关系型数据库往往不支持事务，或者不能严格保证ACID的特性，特性：BASE，只能实现基本的一致性。</p>
<h4 id="总结">总结</h4>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 45%" />
<col style="width: 45%" />
</colgroup>
<thead>
<tr>
<th></th>
<th>SQL</th>
<th>NoSQL</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>数据结构</strong></td>
<td>结构化</td>
<td>非结构化</td>
</tr>
<tr>
<td><strong>数据关联</strong></td>
<td>关联的</td>
<td>非关联的</td>
</tr>
<tr>
<td><strong>查询方式</strong></td>
<td>SQL查询</td>
<td>非SQl</td>
</tr>
<tr>
<td><strong>事务特性</strong></td>
<td>ACID</td>
<td>BASE</td>
</tr>
<tr>
<td><strong>存储方式</strong></td>
<td>磁盘</td>
<td>内存</td>
</tr>
<tr>
<td><strong>扩展性</strong></td>
<td>垂直</td>
<td>水平</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>1）数据结构固定<br />2）相关业务对数据安全性、一致性要求较高</td>
<td>1）数据结构不固定<br />2）对一致性、安全性要求不高<br />3）对性能要求</td>
</tr>
</tbody>
</table>
<h3 id="认识redis">认识Redis</h3>
<p>特征：</p>
<ul>
<li>键值（key-value）型，value支持多种不同数据结构，功能丰富</li>
<li>单线程，每个命令具备原子性</li>
<li>低延迟，速度快（基于内存、IO多路复用、良好的编码）</li>
<li>支持数据持久化</li>
<li>支持主从集群、分片集群</li>
<li>支持多语言客户端（java、Python、c等）</li>
</ul>
<h3 id="安装redis">安装Redis</h3>
<h4 id="redis安装说明">Redis安装说明</h4>
<p>大多数企业都是基于Linux服务器来部署项目，而且Redis官方也没有提供Windows版本的安装包。因此课程中我们会基于Linux系统来安装Redis.</p>
<p>此处选择的Linux版本为CentOS 7</p>
<p>Redis的官方网站地址：https://redis.io/</p>
<h4 id="单机安装redis">单机安装Redis</h4>
<h5 id="步骤1.安装redis依赖">步骤1.安装Redis依赖</h5>
<p>Redis是基于C语言编写的，因此首先需要安装Redis所需要的gcc依赖：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc tcl</span><br></pre></td></tr></table></figure>
<h5 id="步骤2.上传安装包并解压">步骤2.上传安装包并解压</h5>
<p>然后将Redis安装包上传到虚拟机的任意目录：</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503131441425.png" /></p>
<p>例如，放到了/usr/local/src 目录：</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503131441437.png" /></p>
<p>解压缩：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf redis-6.2.6.tar.gz</span><br></pre></td></tr></table></figure>
<p>解压后：</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503131441444.png" /></p>
<p>进入redis目录：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> redis-6.2.6</span><br></pre></td></tr></table></figure>
<p>运行编译命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>如果没有出错，应该就安装成功了。</p>
<p>默认的安装路径是在 <code>/usr/local/bin</code>目录下：</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503131441445.png" /></p>
<p>该目录以及默认配置到环境变量，因此可以在任意目录下运行这些命令。其中：</p>
<ul>
<li>redis-cli：是redis提供的命令行客户端</li>
<li>redis-server：是redis的服务端启动脚本</li>
<li>redis-sentinel：是redis的哨兵启动脚本</li>
</ul>
<h5 id="步骤3.启动">步骤3.启动</h5>
<p>redis的启动方式有很多种，例如：</p>
<ul>
<li>默认启动</li>
<li>指定配置启动</li>
<li>开机自启</li>
</ul>
<h6 id="默认启动">默认启动</h6>
<p>安装完成后，在任意目录输入redis-server命令即可启动Redis：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure>
<p>如图：</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503131441451.png" /></p>
<p>这种启动属于<code>前台启动</code>，会阻塞整个会话窗口，窗口关闭或者按下<code>CTRL + C</code>则Redis停止。不推荐使用。</p>
<h6 id="指定配置启动">指定配置启动</h6>
<p>如果要让Redis以<code>后台</code>方式启动，则必须修改Redis配置文件，就在我们之前解压的redis安装包下（<code>/usr/local/src/redis-6.2.6</code>），名字叫redis.conf：</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503131441455.png" /></p>
<p>我们先将这个配置文件备份一份：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp redis.conf redis.conf.bck</span><br></pre></td></tr></table></figure>
<p>然后修改redis.conf文件中的一些配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监听的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span></span><br><span class="line"><span class="attr">bind</span> <span class="string">0.0.0.0</span></span><br><span class="line"><span class="comment"># 守护进程，修改为yes后即可后台运行</span></span><br><span class="line"><span class="attr">daemonize</span> <span class="string">yes </span></span><br><span class="line"><span class="comment"># 密码，设置后访问Redis必须输入密码</span></span><br><span class="line"><span class="attr">requirepass</span> <span class="string">123321</span></span><br></pre></td></tr></table></figure>
<p>Redis的其它常见配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监听的端口</span></span><br><span class="line"><span class="attr">port</span> <span class="string">6379</span></span><br><span class="line"><span class="comment"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">.</span></span><br><span class="line"><span class="comment"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span></span><br><span class="line"><span class="attr">databases</span> <span class="string">1</span></span><br><span class="line"><span class="comment"># 设置redis能够使用的最大内存</span></span><br><span class="line"><span class="attr">maxmemory</span> <span class="string">512mb</span></span><br><span class="line"><span class="comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span></span><br><span class="line"><span class="attr">logfile</span> <span class="string">&quot;redis.log&quot;</span></span><br></pre></td></tr></table></figure>
<p>启动Redis：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入redis安装目录 </span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/src/redis-6.2.6</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure>
<p>停止服务：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，</span></span><br><span class="line"><span class="comment"># 因为之前配置了密码，因此需要通过 -u 来指定密码</span></span><br><span class="line">redis-cli -u 123321 shutdown</span><br></pre></td></tr></table></figure>
<h6 id="开机自启">开机自启</h6>
<p>我们也可以通过配置来实现开机自启。</p>
<p>首先，新建一个系统服务文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/systemd/system/redis.service</span><br></pre></td></tr></table></figure>
<p>内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=redis-server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<p>然后重载系统服务：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure>
<p>现在，我们可以用下面这组命令来操作redis了：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start redis</span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">systemctl stop redis</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart redis</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">systemctl status redis</span><br></pre></td></tr></table></figure>
<p>执行下面的命令，可以让redis开机自启：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> redis</span><br></pre></td></tr></table></figure>
<h4 id="redis命令行客户端">Redis命令行客户端</h4>
<p>Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli [options] [commonds]</span><br></pre></td></tr></table></figure>
<p>其中常见的options有：</p>
<ul>
<li><code>-h 127.0.0.1</code>：指定要连接的redis节点的IP地址，默认是127.0.0.1</li>
<li><code>-p 6379</code>：指定要连接的redis节点的端口，默认是6379</li>
<li><code>-a 123321</code>：指定redis的访问密码</li>
</ul>
<p>其中的commonds就是Redis的操作命令，例如：</p>
<ul>
<li><code>ping</code>：与redis服务端做心跳测试，服务端正常会返回<code>pong</code></li>
</ul>
<p>不指定commonds时，会进入<code>redis-cli</code>的交互控制台：</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503131502243.png" /></p>
<h4 id="图形化桌面客户端">图形化桌面客户端</h4>
<p>GitHub上的大神编写了Redis的图形化桌面客户端，地址：https://github.com/uglide/RedisDesktopManager</p>
<p>不过该仓库提供的是RedisDesktopManager的源码，并未提供windows安装包。</p>
<p>在下面这个仓库可以找到安装包：https://github.com/lework/RedisDesktopManager-Windows/releases，然后安装</p>
<h5 id="建立连接">建立连接</h5>
<p>点击左上角的<code>连接到Redis服务器</code>按钮：</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503131503909.png" /></p>
<p>在弹出的窗口中填写Redis服务信息：</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503131503911.png" /></p>
<p>点击测试连接，看连接是否成功。</p>
<blockquote>
<p>注意：需要先设置虚拟机的防火墙</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --permanent --add-port=6379/tcp </span><br><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure>
</blockquote>
<p>点击确定后，在左侧菜单会出现这个链接：</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503131503916.png" /></p>
<p>点击即可建立连接了：</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503131503919.png" /></p>
<p>Redis默认有16个仓库，编号从0至15.
通过配置文件可以设置仓库数量，但是不超过16，并且不能自定义仓库名称。</p>
<p>如果是基于redis-cli连接Redis服务，可以通过select命令来选择数据库：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择 0号库</span></span><br><span class="line">select 0</span><br></pre></td></tr></table></figure>
<h2 id="redis命令">Redis命令</h2>
<h3 id="数据结构介绍">数据结构介绍</h3>
<p>Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样：</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503141011784.png" /></p>
<p>GEO：地理位置</p>
<p><strong>贴心小建议：命令不要死记，学会查询就好啦</strong></p>
<p>Redis为了方便我们学习，将操作不同数据类型的命令也做了分组，在官网（
https://redis.io/commands ）可以查看到不同的命令。</p>
<p>或者通过Help命令来帮助我们去查看命令：</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503141016038.png" /></p>
<h3 id="通用命令">通用命令</h3>
<p>通用指令是部分数据类型的都可以使用的指令，可以通过<code>help @generic</code>查看有哪些通用命令，常见的有：</p>
<ul>
<li><p>KEYS：查看符合模板的所有key</p>
<ul>
<li>```sh 127.0.0.1:6379&gt; keys *
<ol type="1">
<li>"name"</li>
<li>"age" 127.0.0.1:6379&gt;</li>
</ol>
<h1 id="查询以a开头的key">查询以a开头的key</h1>
127.0.0.1:6379&gt; keys a*
<ol type="1">
<li>"age" 127.0.0.1:6379&gt; <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    **贴心小提示：在生产环境下，不推荐使用keys 命令，因为这个命令在key过多的情况下，效率不高，模糊查询**</span><br><span class="line"></span><br><span class="line">- DEL：删除一个指定的key</span><br><span class="line"></span><br><span class="line">  - ```sh</span><br><span class="line">    127.0.0.1:6379&gt; del name #删除单个</span><br><span class="line">    (integer) 1  #成功删除1个</span><br><span class="line">    </span><br><span class="line">    127.0.0.1:6379&gt; keys *</span><br><span class="line">    1) &quot;age&quot;</span><br><span class="line">    </span><br><span class="line">    127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3 #批量添加数据</span><br><span class="line">    OK</span><br><span class="line">    </span><br><span class="line">    127.0.0.1:6379&gt; keys *</span><br><span class="line">    1) &quot;k3&quot;</span><br><span class="line">    2) &quot;k2&quot;</span><br><span class="line">    3) &quot;k1&quot;</span><br><span class="line">    4) &quot;age&quot;</span><br><span class="line">    </span><br><span class="line">    127.0.0.1:6379&gt; del k1 k2 k3 k4</span><br><span class="line">    (integer) 3   #此处返回的是成功删除的key，由于redis中只有k1,k2,k3 所以只成功删除3个，最终返回</span><br><span class="line">    127.0.0.1:6379&gt;</span><br><span class="line">    </span><br><span class="line">    127.0.0.1:6379&gt; keys * #再查询全部的key</span><br><span class="line">    1) &quot;age&quot;	#只剩下一个了</span><br><span class="line">    127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure></li>
</ol></li>
</ul></li>
<li><p>EXISTS：判断key是否存在</p>
<ul>
<li><p>```sh 127.0.0.1:6379&gt; help EXISTS</p>
<p>EXISTS key [key ...] summary: Determine if a key exists since: 1.0.0
group: generic</p>
<p>127.0.0.1:6379&gt; exists age (integer) 1</p>
<p>127.0.0.1:6379&gt; exists name (integer) 0 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除（为什么会存在这个命令：因为Redis是在内存中存储的，内存非常宝贵）</span><br><span class="line"></span><br><span class="line">  - ```sh</span><br><span class="line">    127.0.0.1:6379&gt; expire age 10</span><br><span class="line">    (integer) 1</span><br><span class="line">    </span><br><span class="line">    127.0.0.1:6379&gt; ttl age</span><br><span class="line">    (integer) 8</span><br><span class="line">    </span><br><span class="line">    127.0.0.1:6379&gt; ttl age</span><br><span class="line">    (integer) 6</span><br><span class="line">    </span><br><span class="line">    127.0.0.1:6379&gt; ttl age</span><br><span class="line">    (integer) -2</span><br><span class="line">    </span><br><span class="line">    127.0.0.1:6379&gt; ttl age</span><br><span class="line">    (integer) -2  #当这个key过期了，那么此时查询出来就是-2 </span><br><span class="line">    </span><br><span class="line">    127.0.0.1:6379&gt; keys *</span><br><span class="line">    (empty list or set)</span><br><span class="line">    </span><br><span class="line">    127.0.0.1:6379&gt; set age 10 #如果没有设置过期时间</span><br><span class="line">    OK</span><br><span class="line">    </span><br><span class="line">    127.0.0.1:6379&gt; ttl age</span><br><span class="line">    (integer) -1  # ttl的返回值就是-1</span><br></pre></td></tr></table></figure></p></li>
</ul></li>
<li><p>TTL：查看一个KEY的剩余有效期</p></li>
</ul>
<h3 id="string命令">String命令</h3>
<p>String类型，也就是字符串类型，是Redis中最简单的存储类型。</p>
<p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p>
<ul>
<li>string：普通字符串</li>
<li>int：整数类型，可以做自增，自减操作</li>
<li>float：浮点类型，可以做自增，自减操作</li>
</ul>
<table>
<thead>
<tr>
<th>KEY</th>
<th>VALUE</th>
</tr>
</thead>
<tbody>
<tr>
<td>msg</td>
<td>hello world</td>
</tr>
<tr>
<td>num</td>
<td>10</td>
</tr>
<tr>
<td>score</td>
<td>92.5</td>
</tr>
</tbody>
</table>
<p>String的常见命令有：</p>
<ul>
<li>SET：添加或者修改已经存在的一个String类型的键值对</li>
<li>GET：根据key获取String类型的value</li>
<li>MSET：批量添加多个String类型的键值对</li>
<li>MGET：根据多个key获取多个String类型的value</li>
<li>INCR：让一个整型的key自增1</li>
<li>INCRBY:让一个整型的key自增并指定步长（也可以是负数，就是自减），例如：incrby
num 2 让num值自增2</li>
<li>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</li>
<li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行
<ul>
<li>其实和<code>set 键 nx</code>效果一样，nx是set的参数</li>
</ul></li>
<li>SETEX：添加一个String类型的键值对，并且指定有效期
<ul>
<li>其实和<code>set 键 ex 数字（表时间）</code></li>
</ul></li>
</ul>
<h3 id="key的层级结构">Key的层级结构</h3>
<p><strong>问题：</strong>Redis没有类似MySQL中的Table的概念，我们该如何区分不同类型的key呢？例如，需要存储用户.商品信息到redis，有一个用户id是1，有一个商品id恰好也是1，此时如果使用id作为key，那就会冲突了，该怎么办？</p>
<p><strong>解决方案：</strong>可以通过给key添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范。</p>
<p>Redis的key允许有多个单词形成层级结构，多个单词之间用<code>:</code>隔开，格式如下：<code>项目名:业务名:类型:id</code>。这个格式并非固定，也可以根据自己的需求来删除或添加词条。</p>
<p>例如我们的项目名称叫
heima，有user和product两种不同类型的数据，我们可以这样定义key：</p>
<ul>
<li><p>user相关的key：<strong>heima:user:1</strong></p></li>
<li><p>product相关的key：<strong>heima:product:1</strong></p></li>
</ul>
<p>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储：</p>
<table>
<thead>
<tr>
<th><strong>KEY</strong></th>
<th><strong>VALUE</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>heima:user:1</td>
<td>{"id":1, "name": "Jack", "age": 21}</td>
</tr>
<tr>
<td>heima:product:1</td>
<td>{"id":1, "name": "小米11", "price": 4999}</td>
</tr>
</tbody>
</table>
<p>一旦我们向redis采用这样的方式存储，那么在可视化界面中，redis会以层级结构来进行存储，形成类似于这样的结构，更加方便Redis获取数据。</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503141112678.png" /></p>
<h3 id="hash命令">Hash命令</h3>
<p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p>
<p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便：</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503141341609.png" /></p>
<p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503141341613.png" /></p>
<p><strong>Hash类型的常见命令</strong></p>
<ul>
<li><p>HSET key field value：添加或者修改hash类型key的field的值</p>
<ul>
<li>```sh 127.0.0.1:6379&gt; HSET heima:user:3 name Lucy//大key是
heima:user:3 小key是name，小value是Lucy (integer) 1 127.0.0.1:6379&gt;
HSET heima:user:3 age 21// 如果操作不存在的数据，则是新增 (integer) 1
127.0.0.1:6379&gt; HSET heima:user:3 age 17
//如果操作存在的数据，则是修改 (integer) 0 127.0.0.1:6379&gt; HGET
heima:user:3 name "Lucy" 127.0.0.1:6379&gt; HGET heima:user:3 age "17"
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- HGET key field：获取一个hash类型key的field的值</span><br><span class="line"></span><br><span class="line">- HMSET：批量添加多个hash类型key的field的值</span><br><span class="line"></span><br><span class="line">- HMGET：批量获取多个hash类型key的field的值</span><br><span class="line"></span><br><span class="line">- HGETALL：获取一个hash类型的key中的所有的field和value</span><br><span class="line"></span><br><span class="line">- HKEYS：获取一个hash类型的key中的所有的field</span><br><span class="line"></span><br><span class="line">- HINCRBY:让一个hash类型key的字段值自增并指定步长</span><br><span class="line"></span><br><span class="line">- HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### List命令</span><br><span class="line"></span><br><span class="line">Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构，既可以支持正向检索和也可以支持反向检索。</span><br><span class="line"></span><br><span class="line">特征也与LinkedList类似：</span><br><span class="line"></span><br><span class="line">* 有序</span><br><span class="line">* 元素可以重复</span><br><span class="line">* 插入和删除快</span><br><span class="line">* 查询速度一般</span><br><span class="line"></span><br><span class="line">常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</span><br><span class="line"></span><br><span class="line">**List的常见命令有：**</span><br><span class="line"></span><br><span class="line">- LPUSH key element ... ：向列表左侧插入一个或多个元素</span><br><span class="line">- LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</span><br><span class="line">- RPUSH key element ... ：向列表右侧插入一个或多个元素</span><br><span class="line">- RPOP key：移除并返回列表右侧的第一个元素</span><br><span class="line">- LRANGE key star end：返回一段角标范围内的所有元素</span><br><span class="line">- BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</span><br><span class="line"></span><br><span class="line">* LPUSH和RPUSH</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">127.0.0.1:6379&gt; LPUSH users 1 2 3</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; RPUSH users 4 5 6</span><br><span class="line">(integer) 6</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>以上操作完之后是<code>3 2 1 4 5 6</code></p></li>
<li><p>LPOP和RPOP</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LPOP users</span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; RPOP users</span><br><span class="line"><span class="string">&quot;6&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>以上操作完之后是<code>2 1 4 5</code></li>
<li>LRANGE</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LRANGE users <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;4&quot;</span></span><br></pre></td></tr></table></figure>
<p>如何用List结构模拟一个栈？</p>
<ul>
<li>入口和出口在同一边</li>
</ul>
<p>如何用List结构模拟一个队列？</p>
<ul>
<li>入口和出口在不同边</li>
</ul>
<p>如何用List结构模拟一个阻塞队列？</p>
<ul>
<li>入口和出口在不同边</li>
<li>出队时采用BLPOP或BRPOP</li>
</ul>
<h3 id="set命令">Set命令</h3>
<p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p>
<ul>
<li>无序</li>
<li>元素不可重复</li>
<li>查找快</li>
<li>支持交集、并集、差集等功能</li>
</ul>
<p><strong>Set类型的常见命令</strong></p>
<ul>
<li>SADD key member ... ：向set中添加一个或多个元素</li>
<li>SREM key member ... : 移除set中的指定元素</li>
<li>SCARD key： 返回set中元素的个数</li>
<li>SISMEMBER key member：判断一个元素是否存在于set中</li>
<li>SMEMBERS：获取set中的所有元素</li>
<li>SINTER key1 key2 ... ：求key1与key2的交集</li>
<li>SDIFF key1 key2 ... ：求key1与key2的差集</li>
<li>SUNION key1 key2 ..：求key1和key2的并集</li>
</ul>
<h3 id="sortedset命令">SortedSet命令</h3>
<p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加
hash表。</p>
<p>SortedSet具备下列特性：</p>
<ul>
<li>可排序</li>
<li>元素不重复</li>
<li>查询速度快</li>
</ul>
<p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p>
<p>SortedSet的常见命令有：</p>
<ul>
<li>ZADD key score member：添加一个或多个元素到sorted set
，如果已经存在则更新其score值</li>
<li>ZREM key member：删除sorted set中的一个指定元素</li>
<li>ZSCORE key member : 获取sorted set中的指定元素的score值</li>
<li>ZRANK key member：获取sorted set 中的指定元素的排名</li>
<li>ZCARD key：获取sorted set中的元素个数</li>
<li>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</li>
<li>ZINCRBY key increment member：让sorted
set中的指定元素自增，步长为指定的increment值</li>
<li>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素</li>
<li>ZRANGEBYSCORE key min
max：按照score排序后，获取指定score范围内的元素</li>
<li>ZDIFF.ZINTER.ZUNION：求差集.交集.并集</li>
</ul>
<p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</p>
<ul>
<li><strong>升序</strong>获取sorted set 中的指定元素的排名：ZRANK key
member</li>
<li><strong>降序</strong>获取sorted set 中的指定元素的排名：ZREVRANK key
memeber</li>
</ul>
<h2 id="redis的java客户端-jedis">Redis的Java客户端-Jedis</h2>
<h3 id="快速入门">快速入门</h3>
<p>1.创建工程</p>
<p>2.引入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--jedis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>/version&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--单元测试--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>3.建立连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.建立连接</span></span><br><span class="line">    <span class="comment">// jedis = new Jedis(&quot;192.168.150.101&quot;, 6379);</span></span><br><span class="line">    jedis = JedisConnectionFactory.getJedis();</span><br><span class="line">    <span class="comment">// 2.设置密码</span></span><br><span class="line">    jedis.auth(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.选择库</span></span><br><span class="line">    jedis.select(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 存入数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;虎哥&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">    <span class="comment">// 获取数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 插入hash数据</span></span><br><span class="line">    jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取</span></span><br><span class="line">    Map&lt;String, String&gt; map = jedis.hgetAll(<span class="string">&quot;user:1&quot;</span>);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5.释放资源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jedis连接池">Jedis连接池</h3>
<p>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式</p>
<p>有关池化思想，并不仅仅是这里会使用，很多地方都有，比如说我们的数据库连接池，比如我们tomcat中的线程池，这些都是池化思想的体现</p>
<p><strong>创建Jedis连接池</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectionFacotry</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">static</span> &#123;</span><br><span class="line">         <span class="comment">//配置连接池</span></span><br><span class="line">         <span class="type">JedisPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">         poolConfig.setMaxTotal(<span class="number">8</span>);</span><br><span class="line">         poolConfig.setMaxIdle(<span class="number">8</span>);</span><br><span class="line">         poolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line">         poolConfig.setMaxWait(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">         <span class="comment">//创建连接池对象</span></span><br><span class="line">         jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(poolConfig,</span><br><span class="line">                 <span class="string">&quot;192.168.57.130&quot;</span>,<span class="number">6379</span>,<span class="number">1000</span>,<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li><p>JedisConnectionFacotry：工厂设计模式是实际开发中非常常用的一种设计模式，我们可以使用工厂，去降低代的耦合，比如Spring中的Bean的创建，就用到了工厂设计模式</p></li>
<li><p>静态代码块：随着类的加载而加载，确保只能执行一次，我们在加载当前工厂类的时候，就可以执行static的操作完成对
连接池的初始化</p></li>
<li><p>最后提供返回连接池中连接的方法.</p></li>
</ul>
<p><strong>改造原始代码</strong></p>
<p><strong>代码说明:</strong></p>
<p>1.在我们完成了使用工厂设计模式来完成代码的编写之后，我们在获得连接时，就可以通过工厂来获得，而不用直接去new对象，降低耦合，并且使用的还是连接池对象。</p>
<p>2.当我们使用了连接池后，当我们关闭连接其实并不是关闭，而是将Jedis还回连接池的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@BeforeEach</span></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="comment">//建立连接</span></span><br><span class="line">     <span class="comment">/*jedis = new Jedis(&quot;127.0.0.1&quot;,6379);*/</span></span><br><span class="line">     jedis = JedisConnectionFacotry.getJedis();</span><br><span class="line">      <span class="comment">//选择库</span></span><br><span class="line">     jedis.select(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">         jedis.close();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2
id="redis的java客户端-springdataredis">Redis的Java客户端-SpringDataRedis</h2>
<p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：https://spring.io/projects/spring-data-redis</p>
<ul>
<li>提供了对不同Redis客户端的整合（Lettuce和Jedis）</li>
<li>提供了RedisTemplate统一API来操作Redis</li>
<li>支持Redis的发布订阅模型</li>
<li>支持Redis哨兵和Redis集群</li>
<li>支持基于Lettuce的响应式编程</li>
<li>支持基于JDK.JSON.字符串.Spring对象的数据序列化及反序列化</li>
<li>支持基于Redis的JDKCollection实现</li>
</ul>
<p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503141603696.png" /></p>
<h4 id="快速入门-1">快速入门</h4>
<p>1.导入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--redis依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--common-pool--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2.配置文件</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.57</span><span class="number">.130</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123321</span></span><br><span class="line">      <span class="attr">lettuce:</span></span><br><span class="line">        <span class="attr">pool:</span></span><br><span class="line">          <span class="attr">max-active:</span> <span class="number">8</span>  <span class="comment">#最大连接</span></span><br><span class="line">          <span class="attr">max-idle:</span> <span class="number">8</span>  <span class="comment">#最大空闲连接</span></span><br><span class="line">          <span class="attr">min-idle:</span> <span class="number">0</span>  <span class="comment">#最小空闲连接</span></span><br><span class="line">          <span class="attr">max-wait:</span> <span class="string">1000ms</span>  <span class="comment">#最小空闲连接</span></span><br></pre></td></tr></table></figure>
<p>3.测试代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisDemoApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 写入一条String数据</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;虎哥&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取string数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数据序列化器">数据序列化器</h4>
<p>RedisTemplate可以接收任意Object作为值写入Redis，只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果是这样的：</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503141813595.png" /></p>
<p>缺点：</p>
<ul>
<li>可读性差</li>
<li>内存占用较大</li>
</ul>
<p>我们可以自定义RedisTemplate的序列化方式，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 创建JSON序列化工具</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jsonRedisSerializer</span> <span class="operator">=</span> </span><br><span class="line">            							<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// 设置Key的序列化</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// 设置Value的序列化</span></span><br><span class="line">        template.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里采用了JSON序列化来代替默认的JDK序列化方式。最终结果如图：</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503141815710.png" /></p>
<p>整体可读性有了很大提升，并且能将Java对象自动的序列化为JSON字符串，并且查询时能自动把JSON反序列化为Java对象。不过，其中记录了序列化时对应的class名称，目的是为了查询时实现自动反序列化。这会带来额外的内存开销。</p>
<h4 id="stringredistemplate">StringRedisTemplate</h4>
<p>尽管JSON的序列化方式可以满足我们的需求，但依然存在一些问题，如上图。</p>
<p>为了在反序列化时知道对象的类型，JSON序列化器会将类的class类型写入json结果中，存入Redis，会带来额外的内存开销。</p>
<p>为了减少内存的消耗，我们可以采用手动序列化的方式，换句话说，就是不借助默认的序列化器，而是我们自己来控制序列化的动作，同时，我们只采用String的序列化器，这样，在存储value时，我们就不需要在内存中就不用多存储数据，从而节约我们的内存空间。</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503141818150.png" /></p>
<p>这种用法比较普遍，因此SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式。</p>
<p>省去了我们自定义RedisTemplate的序列化方式的步骤，而是直接使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisStringTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 写入一条String数据</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;verify:phone:13600527634&quot;</span>, <span class="string">&quot;124143&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取string数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;虎哥&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        <span class="comment">// 手动序列化</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line">        <span class="comment">// 写入数据</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:200&quot;</span>, json);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonUser</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:200&quot;</span>);</span><br><span class="line">        <span class="comment">// 手动反序列化</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> mapper.readValue(jsonUser, User.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;user1 = &quot;</span> + user1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503141826954.png" /></p>
<p><strong>总结：</strong></p>
<p>RedisTemplate的两种序列化实践方案：</p>
<ul>
<li>方案一：
<ul>
<li>自定义RedisTemplate</li>
<li>修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer</li>
</ul></li>
<li>方案二：
<ul>
<li>使用StringRedisTemplate</li>
<li>写入Redis时，手动把对象序列化为JSON</li>
<li>读取Redis时，手动把读取到的JSON反序列化为对象</li>
</ul></li>
</ul>
<h4 id="hash结构操作">Hash结构操作</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisStringTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForHash().put(<span class="string">&quot;user:400&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;虎哥&quot;</span>);</span><br><span class="line">        stringRedisTemplate.opsForHash().put(<span class="string">&quot;user:400&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Map&lt;Object, Object&gt; entries = stringRedisTemplate.opsForHash().entries(<span class="string">&quot;user:400&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;entries = &quot;</span> + entries);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="实战篇">实战篇</h1>
<h2 id="短信登录">短信登录</h2>
<p>流程：</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503191656667.png" /></p>
<p>集群的session共享问题：</p>
<p>session共享问题：多台Tomcat并不共享session存储空间，当请求切换到不同tomcat服务时导致数据丢失的问题。</p>
<p>session的替代方案应该满足：</p>
<ul>
<li>数据共享</li>
<li>内存存储</li>
<li>key、value结构</li>
</ul>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503211549934.png" /></p>
<p>改进后的流程：</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503211557167.png" /></p>
<p>保存用户到Redis中不用手机号作为Redis的key是因为：要返回给前端并放在authorization中，为了以后登录时进行验证，如果用手机号的话容易泄漏。</p>
<p>登录拦截器的优化：</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503211644076.png" /></p>
<p>原来的登录拦截器存在的问题：不拦截一些不需要登录的api，比如首页、获取验证码等，如果将刷新token有效期的代码放在这里面，就会导致用户在访问首页或者其他不被拦截的api时token不会被刷线。</p>
<p>改进：</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503211646385.png" /></p>
<h2 id="商户查询">商户查询</h2>
<h3 id="什么是缓存">什么是缓存</h3>
<p>缓存就是数据交换的缓存区（称作Cache），是贮存数据的临时地方，一般读写性能较高。</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503211938521.png" /></p>
<p>缓存的作用：</p>
<ul>
<li>降低后端负载</li>
<li>提高读写效率，降低响应时间</li>
</ul>
<p>缓存的成本：</p>
<ul>
<li>数据一致性成本</li>
<li>代码维护成本</li>
<li>运维成本</li>
</ul>
<h3 id="缓存更新策略">缓存更新策略</h3>
<table>
<colgroup>
<col style="width: 4%" />
<col style="width: 34%" />
<col style="width: 34%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr>
<th></th>
<th>内存淘汰</th>
<th>超时剔除</th>
<th>主动更新</th>
</tr>
</thead>
<tbody>
<tr>
<td>说明</td>
<td>不用自己维护，利用Redis的内存淘汰机制，当内存不足时自动淘汰部分数据。下次查询时更新缓存。</td>
<td>给缓存数据添加TTL时间，到期后自动删除缓存。下次查询时更新缓存。</td>
<td>编写业务逻辑，在修改数据库的同时，更新缓存。</td>
</tr>
<tr>
<td>一致性</td>
<td>差</td>
<td>一般</td>
<td>好</td>
</tr>
<tr>
<td>维护成本</td>
<td>无</td>
<td>低</td>
<td>高</td>
</tr>
</tbody>
</table>
<p>业务场景：</p>
<ul>
<li>低一致性需求：使用内存淘汰机制。例如店铺类型的查询缓存。</li>
<li>高一致性需求：主动更新，并以超时剔除作为兜底方案。例如店铺详情查询的缓存。</li>
</ul>
<h4 id="主动更新策略">主动更新策略</h4>
<ul>
<li>Cache Aside
Pattern：由缓存的调用者，在更新数据库的同时更新缓存。（主要使用）</li>
<li>Read/Write Through
Pattern：缓存与数据库整合为一个服务，由服务来维护一致性。调用者调用该服务，无需关心缓存一致性问题。</li>
<li>Write Behind Caching
Pattern：调用者只操作缓存，由其他线程异步的将缓存数据持久化到数据库，保证最终一致。</li>
</ul>
<p>Cache Aside Pattern存在的三个问题</p>
<ul>
<li>删除缓存还是更新缓存？
<ul>
<li>更新缓存：每次更新数据库都要更新缓存，无效写操作较多</li>
<li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存</li>
</ul></li>
<li>如何保证缓存与数据库的操作的同时成功或失败？
<ul>
<li>单体系统，将缓存与数据库操作放在一个事务</li>
<li>分布式系统，利用TCC等分布事务方案</li>
</ul></li>
<li>先操作缓存还是先操作数据库？
<ul>
<li>先删除缓存，再操作数据库</li>
<li>先操作数据库，再删除缓存</li>
</ul></li>
</ul>
<h5 id="先删除缓存再操作数据库">先删除缓存，再操作数据库</h5>
<p>正常情况：</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503261519943.png" /></p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>缓存</th>
<th>数据库</th>
</tr>
</thead>
<tbody>
<tr>
<td>初始</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>10</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>20</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>20</td>
</tr>
<tr>
<td>4</td>
<td>20</td>
<td>20</td>
</tr>
</tbody>
</table>
<p>异常情况：</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503261520155.png" /></p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>缓存</th>
<th>数据库</th>
</tr>
</thead>
<tbody>
<tr>
<td>初始</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>10</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>10</td>
</tr>
<tr>
<td>3</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td>4</td>
<td>10</td>
<td>20</td>
</tr>
</tbody>
</table>
<p>因为更新数据库的操作一般是很慢的，而删除缓存的操作是很快的，很可能线程1删除缓存之后，先让线程2执行。</p>
<p>这种情况发生的可能性比较高。</p>
<h5 id="先操作数据库再删除缓存">先操作数据库，再删除缓存</h5>
<p>正常情况：</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503261524686.png" /></p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>缓存</th>
<th>数据库</th>
</tr>
</thead>
<tbody>
<tr>
<td>初始</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td>1</td>
<td>10</td>
<td>20</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>20</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>20</td>
</tr>
<tr>
<td>4</td>
<td>20</td>
<td>20</td>
</tr>
</tbody>
</table>
<p>异常情况（假设线程1查询时，缓存恰好失效了）：</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503261531031.png" /></p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>缓存</th>
<th>数据库</th>
</tr>
</thead>
<tbody>
<tr>
<td>初始</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>10</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>20</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>20</td>
</tr>
<tr>
<td>4</td>
<td>10</td>
<td>20</td>
</tr>
</tbody>
</table>
<p>情况发生的条件：</p>
<ul>
<li>两个线程在并行执行</li>
<li>线程1查询时，缓存恰好失效</li>
<li>线程1查询后，要写入缓存之间（之间微秒级）突然来了一个线程（这里是线程2）要更新数据库，删缓存。</li>
</ul>
<p>综合分析，可能性比较低。</p>
<h4 id="缓存更新策略的最佳实践">缓存更新策略的最佳实践</h4>
<ul>
<li>删除缓存还是更新缓存？删除缓存</li>
<li>方案2（即先操作数据库，再删除缓存）发生异常情况的可能性较低。</li>
</ul>
<p>1.低一致性需求：使用Redis自带的内存淘汰机制</p>
<p>2.高一致性需求：主动更新，并以超时剔除作为兜底方案</p>
<ul>
<li>读操作：
<ul>
<li>缓存命中则直接返回</li>
<li>缓存未命中则查询数据库，并写入缓存，设定超时时间</li>
</ul></li>
<li>写操作：
<ul>
<li>先写数据库，然后再删除缓存</li>
<li>要确保数据库与缓存操作的原子性</li>
</ul></li>
</ul>
<h3 id="缓存穿透">缓存穿透</h3>
<p>缓存穿透是指客户端请求的数据在缓存中和数据库都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p>
<p>危害：</p>
<p>常见的解决方案有两种：</p>
<ul>
<li>缓存空对象
<ul>
<li>优点：实现简单，维护方便</li>
<li>缺点：
<ul>
<li>额外的内存消耗（比如请求一堆不存在的id，就会导致缓存中存储大量不存在id的null对象。<strong>解决办法</strong>：设置较短的TTL）</li>
<li>可能造成短期的不一致（比如请求一个不存在的id，然后缓存中存储了它的null对象，然后插入了这个id的商铺，再查询这个id，查到的是缓存中的null对象。<strong>解决办法</strong>：插入这条数据的时候，主动在缓存中覆盖数据）</li>
</ul></li>
</ul></li>
<li>布隆过滤
<ul>
<li>原理：可以简单理解成一个byte数组，把数据库中的数据基于某一种hash算法计算出hash值，然后将这些hash值转换成二进制保存到布隆过滤器里。判断数据是否存在是判断对应的位置是0还是1。这种存在判断是概率上的统计，不是百分百的准确。<strong>重点</strong>：当布隆过滤器说不存在时，百分百不存在；当布隆过滤器说存在时，不一定存在。</li>
<li>优点：内存占用较少，没有多余key</li>
<li>缺点：
<ul>
<li>实现复杂</li>
<li>存在误判可能（当布隆过滤器说不存在时，百分百不存在；当布隆过滤器说存在时，不一定存在。）</li>
</ul></li>
</ul></li>
</ul>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503261612599.png" /></p>
<h4 id="解决商铺查询的缓存穿透问题">解决商铺查询的缓存穿透问题</h4>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503261624010.png" /></p>
<h4 id="总结-1">总结</h4>
<p>缓存穿透产生的原因是什么？</p>
<p>用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力</p>
<p>缓存穿透的解决方案有哪些？</p>
<ul>
<li>缓存null值（被动）</li>
<li>布隆过滤（被动）</li>
<li>增强id的复杂度，避免被猜测id规律</li>
<li>做好数据的基础格式校验（比如0这种id）</li>
<li>加强用户权限校验（要登录才能访问，或者访问频率限制）</li>
<li>做好热点参数的限流</li>
</ul>
<h3 id="缓存雪崩">缓存雪崩</h3>
<p>缓存雪崩是指在<strong>同一时段大量的缓存key同时失效</strong>或者<strong>Redis服务宕机</strong>，导致大量请求到达数据库，带来巨大压力。</p>
<p>解决方案：</p>
<ul>
<li>给不同的Key的TTL添加随机值（针对同一时段大量的缓存key同时失效）</li>
<li>利用Redis集群提高服务的可用性</li>
<li>给缓存业务添加降级限流策略</li>
<li>给业务添加多级缓存</li>
</ul>
<h3 id="缓存击穿">缓存击穿</h3>
<p>缓存击穿问题也叫热点Key问题，就是一个被<strong>高并发访问</strong>并且<strong>缓存重建业务较复杂</strong>的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503261653045.png" /></p>
<p>图中查询数据库，重建缓存的线段比较长，表示所需时间比较长。</p>
<p>常见的解决方案有两种：</p>
<ul>
<li>互斥锁（只有一个线程能获取锁，其他线程都需要等待，所以性能上会比较差）
<ul>
<li><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503261709782.png" /></li>
</ul></li>
<li>逻辑过期（向redis存储数据时，不设置TTL，逻辑过期不是真正的过期，它要求我们在存储数据到redis的时候，额外的要添加一个过期时间的字段，这个key本身是不用去设置ttl的，所以它的过期时间不是由redis控制的，而是由我们程序员自己去判断它是否过期）
<ul>
<li><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503261710253.png" /></li>
</ul></li>
</ul>
<table style="width:100%;">
<colgroup>
<col style="width: 7%" />
<col style="width: 47%" />
<col style="width: 45%" />
</colgroup>
<thead>
<tr>
<th>解决方案</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>互斥锁</td>
<td>1.没有额外的内存消耗<br />2.保证一致性<br />3.实现简单</td>
<td>1.线程需要等待，性能受影响<br />2.可能有死锁风险</td>
</tr>
<tr>
<td>逻辑过期</td>
<td>线程无需等待，性能较好</td>
<td>1.不保证一致性<br />2.有额外内存消耗<br />3.实现复杂</td>
</tr>
</tbody>
</table>
<h4
id="基于互斥锁方式解决缓存击穿问题">基于互斥锁方式解决缓存击穿问题</h4>
<p>利用Redis中string的setnx命令来实现：setnx，对key进行赋值（当且仅当key不存在时赋值）</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503271034998.png" /></p>
<h4
id="基于逻辑过期方式解决缓存击穿问题">基于逻辑过期方式解决缓存击穿问题</h4>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503281405636.png" /></p>
<h2 id="优惠券秒杀">优惠券秒杀</h2>
<h3 id="全局id生成器">全局ID生成器</h3>
<p>当用户抢购时，就会生成订单保存到tb_voucher_order这张表中，而订单表如果使用数据库自增ID就存在一些问题：</p>
<ul>
<li>id的规律性太明显（用户可以间接知晓每日销量）</li>
<li>受单表数据量的限制（订单特别多，不能用单表存储，用多表存储，每个表id自增会重复）</li>
</ul>
<p>全局ID生成器，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：</p>
<ul>
<li>唯一性</li>
<li>高可用</li>
<li>高性能</li>
<li>递增性</li>
<li>安全性</li>
</ul>
<p>为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其他信息：</p>
<p>使用数值类型存储（Long类型，8Byte）</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504021413746.png" /></p>
<p>ID的组成部分：</p>
<ul>
<li>符号位：1bit，永远为0</li>
<li>时间戳：31bit，以秒为单位，可以使用69年</li>
<li>序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID</li>
</ul>
<p>全局唯一ID生成策略：</p>
<ul>
<li>UUID（生成的是十六进制的数值，返回的是字符串结构，没有自增）</li>
<li>Redis自增</li>
<li>snowflake算法（雪花算法）</li>
<li>数据库自增（用一张表专门做自增）</li>
</ul>
<p>Redis自增ID策略：</p>
<ul>
<li>每天一个key，方便统计订单量</li>
<li>ID构造是时间戳+计数器</li>
</ul>
<h3 id="实现秒杀下单">实现秒杀下单</h3>
<p>实现优惠券秒杀下单功能</p>
<p>下单需要判断两点：</p>
<ul>
<li>秒杀是否开始或结束，如果尚未开始或已经结束则无法下单</li>
<li>库存是否充足，不足则无法下单</li>
</ul>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504021547012.png" /></p>
<h3 id="超卖问题">超卖问题</h3>
<p>原库存是1</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504021631709.png" /></p>
<p>超卖问题是点选的多线程安全问题，针对这一问题的常见解决方案就是加锁。</p>
<h4 id="悲观锁和乐观锁">悲观锁和乐观锁</h4>
<p><strong>悲观锁：</strong></p>
<p>认为线程安全问题一定会发生，因此在操作数据之前先获取锁，确保线程串行执行。</p>
<ul>
<li>例如Synchronized、Lock都属于悲观锁</li>
</ul>
<p><strong>乐观锁：</strong></p>
<p>认为线程安全问题不一定会发生，因此不加锁，只是在更新数据时去判断有没有其他线程对数据做了修改。</p>
<ul>
<li>如果没有修改则认为是安全的，自己才更新数据。</li>
<li>如果已经被其他线程修改说明发生了安全问题，此时可以重试或异常。</li>
</ul>
<h5 id="乐观锁">乐观锁</h5>
<p>乐观锁的关键是判断之前查询得到的数据是否有被修改过，常见的方式有两种：</p>
<p><strong>1.版本号法：</strong></p>
<p>原理：查询的版本号和修改时的版本号有没有变，每次修改版本号+1。</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>id</th>
<th>stock</th>
<th>version</th>
</tr>
</thead>
<tbody>
<tr>
<td>初始</td>
<td>10</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>线程1第一步</td>
<td>10</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>线程2第一步</td>
<td>10</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>线程1第二步</td>
<td>10</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>线程2第二步</td>
<td>10</td>
<td>0</td>
<td>2</td>
</tr>
</tbody>
</table>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504021644630.png" /></p>
<p>改进：每次版本号变化的时候库存也会变化，所以可以将库存作为版本号，即每次修改的时候看与查询的时候库存有没有变，没变则修改，<strong>也就是下面的CAS法。</strong></p>
<p><strong>2.CAS法</strong> （compare and set）</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504021656316.png" /></p>
<h5 id="乐观锁解决超卖问题">乐观锁解决超卖问题</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5.扣减库存--修改前</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">    .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)  <span class="comment">// set stock = stock - 1</span></span><br><span class="line">    .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId) <span class="comment">// where id = ?</span></span><br><span class="line">    .update();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.扣减库存--修改后</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">    .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)  <span class="comment">// set stock = stock - 1</span></span><br><span class="line">    .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).eq(<span class="string">&quot;stock&quot;</span>, voucher.getStock())  <span class="comment">// where id = ? and stock = ?</span></span><br><span class="line">    .update();</span><br></pre></td></tr></table></figure>
<p>使用上面的CAS法改写代码，会发现失败率大大增加。</p>
<p><strong>原因是</strong>：假设库存100，有100个线程同步执行，全部查询得到的库存都是100，最先执行的那个线程执行后库存数为99，其他99个线程查询到库存为99（与一开始查询到的库存100不同，不执行）</p>
<p><strong>这里是有并发，但是没有业务安全问题，因为只要大于0就行执行。</strong></p>
<p>乐观锁问题：成功率太低。</p>
<p><strong>改进：</strong></p>
<p>只要库存大于0就能执行。</p>
<h5 id="总结-2">总结</h5>
<p>悲观锁：添加同步锁，让线程串行执行</p>
<ul>
<li>优点：简单粗暴</li>
<li>性能一般</li>
</ul>
<p>乐观锁：不加锁，在更新时判断是否有其他线程在修改</p>
<ul>
<li>优点：性能好</li>
<li>缺点：存在成功率低的问题</li>
</ul>
<h3 id="一人一单">一人一单</h3>
<p>需求：修改秒杀业务，要求同一个优惠券，一个用户只能下一单</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504021844135.png" /></p>
<h4 id="并发安全问题">并发安全问题</h4>
<p>主要是集群中出现的。</p>
<p>假设图中的灰框表示一个单体</p>
<p>每个jvm中都有自己的锁，两个不同的锁监视器，当前jvm的锁监视器只在当前jvm中有效，所以不同单体的线程各自能获取各自的锁。</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504021934584.png" /></p>
<h2 id="分布式锁">分布式锁</h2>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504041630451.png" /></p>
<p>分布式锁：满足分布式系统或集群模式下<strong>多进程可见</strong>并且<strong>互斥</strong>的锁。</p>
<p>分布式锁的核心是实现多进程之间互斥，而满足这一点的方式有很多，常见的有三种：</p>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 27%" />
<col style="width: 26%" />
<col style="width: 35%" />
</colgroup>
<thead>
<tr>
<th></th>
<th>MySQL</th>
<th>Redis</th>
<th>Zookeeper</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>互斥</strong></td>
<td>利用MySQL本身的互斥锁机制</td>
<td>利用setnx这样的互斥命令</td>
<td>利用节点的唯一性和有序性实现互斥</td>
</tr>
<tr>
<td><strong>高可用</strong></td>
<td>好</td>
<td>好</td>
<td>好</td>
</tr>
<tr>
<td><strong>高性能</strong></td>
<td>一般</td>
<td>好</td>
<td>一般</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>断开连接，自动释放锁</td>
<td>利用锁超时时间，到期释放</td>
<td>临时节点，断开连接自动释放</td>
</tr>
</tbody>
</table>
<blockquote>
<p>zookeeper创建节点都是唯一的并且id单调递增。</p>
</blockquote>
<blockquote>
<p>节点的有序性：每创建一个节点，节点的id都是递增的。现在假设很多线程在zookeeper里创建节点，这样id是单调递增的，我们可以约定id最小的那个获取锁成功，这样就实现了互斥。</p>
</blockquote>
<blockquote>
<p>释放锁：删除该节点即可，这样就不是最小的了。</p>
</blockquote>
<h3 id="基于redis的分布式锁">基于Redis的分布式锁</h3>
<p>实现分布式锁需要实现两个基本方法：</p>
<ul>
<li><p>获取锁</p>
<ul>
<li><p>互斥：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加锁，利用setnx的互斥性质，lock是key，thread1是value，nx是互斥，ex是设置超时时间，set + nx = setnx</span></span><br><span class="line">SET lock thread1 NX EX 10</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>释放锁</p>
<ul>
<li><p>手动释放：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 释放锁，删除即可，lock是key</span></span><br><span class="line">DEL lock</span><br></pre></td></tr></table></figure></li>
<li><p>超时释放：获取锁时添加一个超时时间</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 释放锁，删除即可</span></span><br><span class="line">DEL lock</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504041716939.png" /></p>
<h3 id="redis分布式误删问题">Redis分布式误删问题</h3>
<p><strong>极端情况：</strong></p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504051418477.png" /></p>
<p>线程1获取了锁，但是在获取锁后业务发生了阻塞，阻塞时间甚至比锁的超时时间还久（设置锁的时候，设置了超时时间expire
ex），这个时候锁提前释放，但是线程1还没执行完。假设这个时候线程2获取了锁，在线程2执行的过程中，线程1业务执行完了，会执行释放锁，也就将线程2的锁释放了。以此类推，当线程3获取了释放的锁，线程2也会释放锁。</p>
<p><strong>解决方案</strong>：</p>
<p>释放锁的时候查看锁的标识和当前标识是否一致（之前获取锁存了线程id）。</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504051420793.png" /></p>
<p>业务流程图变化：</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504051420405.png" /></p>
<p><strong>需求：</strong>修改之前的分布式锁实现，满足：</p>
<p>1.在获取锁时存入线程提示（可以用UUID表示，不用线程ID的原因：jvm每创建一个线程，ID都会递增。如果是在集群的模式下，有多个jvm，所以线程的id很可能冲突）</p>
<p>2.在释放锁时先获取锁中的线程标示，判断是否与当前线程标示一致</p>
<ul>
<li>如果一致则释放锁</li>
<li>如果不一致则不释放锁</li>
</ul>
<h3 id="分布式锁的原子性问题">分布式锁的原子性问题</h3>
<p>接着上面的思路，假设一种极端情况，当线程1获取锁后执行业务后，判断当前标示和锁中标示一致后，开始释放锁，但是释放锁这个动作被阻塞了（这是很可能存在的，因为jvm的垃圾回收机制，当jvm去做full
GC的时候，会阻塞所有的代码。）当释放锁这个被阻塞的时间足够长，超过锁的超时时间时，会释放锁，其他线程也就能获取锁了，但线程1释放锁的动作阻塞结束，它也就会执行释放锁的动作，也就把线程2的锁释放了。（在之前的代码中，key是一样的，value是uuid+线程id）</p>
<p>以下是之前的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> <span class="keyword">implements</span> <span class="title class_">ILock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>) + <span class="string">&quot;-&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleRedisLock</span><span class="params">(String name, StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取线程表示</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">        <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">// 有自动拆箱的动作，万一是空的会出错，所以要用以下语句</span></span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取线程标示</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">        <span class="comment">// 获取锁中的标示</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line">        <span class="comment">// 判断标示是否一致</span></span><br><span class="line">        <span class="keyword">if</span>(threadId.equals(id)) &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504051452811.png" /></p>
<p>解决方案：</p>
<p>将判断标示的动作和释放锁的动作整合成一个原子动作。</p>
<p>redis中的事务无法看到中间结果，所以我们用Lua脚本。</p>
<p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令（Redis时在执行他们时，会一次性全部执行），确保多条命令执行时的原子性。</p>
<p>介绍一下lua中Redis提供的调用函数，语法如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 执行set name jack</span></span><br><span class="line">redis.call(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 例如，我们要先执行set name Rose，再执行get name，则脚本如下：</span></span><br><span class="line"><span class="comment">-- 先执行 set name jack</span></span><br><span class="line">redis.call(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;jaclk&#x27;</span>)</span><br><span class="line"><span class="comment">-- 再执行get name</span></span><br><span class="line"><span class="keyword">local</span> name = redis.call(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="comment">-- 返回</span></span><br><span class="line"><span class="keyword">return</span> name</span><br></pre></td></tr></table></figure>
<p>写好脚本后，需要用Redis命令来调用脚本，常见命令如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">help</span> @scripting</span><br><span class="line"></span><br><span class="line">  EVAL script numkeys key [key ...] arg [arg ...]</span><br><span class="line">  summary: Execute a Lua script server side</span><br><span class="line">  since: 2.6.0</span><br></pre></td></tr></table></figure>
<p>例如，我们要执行<code>redis.call('set', 'name', 'jack')</code>这个脚本，语法如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用脚本 0代表脚本需要的key类型的参数个数</span></span><br><span class="line">EVAL <span class="string">&quot;return redis.call(&#x27;set&#x27;, &#x27;name&#x27;, &#x27;jack&#x27;)&quot;</span> 0</span><br></pre></td></tr></table></figure>
<p>如果脚本中的key，value不想写死，可以作为参数传递。key类型参数会放入KEYS数组，其他参数会放入ARGV数组，在脚本中可以从KEYS和ARGV数组获取这些参数：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用脚本</span></span><br><span class="line">EVAL <span class="string">&quot;return redis.call(&#x27;set&#x27;, KEYS[1], ARGV[1])&quot;</span> 1 name Rose</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：lua语言中数组下标是从1开始的，不是0</p>
</blockquote>
<p>解决：</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504051521661.png" /></p>
<h3 id="总结-3">总结</h3>
<p>基于Redis的分布式锁实现思路：</p>
<ul>
<li>利用set nx ex获取锁，并设置过期时间，保存线程标示</li>
<li>释放锁时先判断线程标示是否与自己一致，一致则删除锁</li>
</ul>
<p>特性：</p>
<ul>
<li>利用set nx满足互斥性</li>
<li>利用set ex保证故障时锁依然能释放，避免死锁，提高安全性</li>
<li>利用Redis集群保证高可用和高并发特性</li>
</ul>
<h3 id="redisson">Redisson</h3>
<h4 id="基于redis的分布式锁优化">基于Redis的分布式锁优化</h4>
<p>基于setnx实现的分布式锁存在下面的问题：</p>
<ul>
<li>不可重入：同一个线程无法多次获取同一把锁
<ul>
<li>可重入：同一个线程可以多次获取同一把锁。比如一个方法a要去调一个方法b，在方法a中要先去获取锁，然后执行业务去调b，而b里又要去获取同一把锁。这种情况，如果锁是不可重入的，方法b中获取锁显然是会失败的，此时b会等待锁的释放，而锁又无法释放，因为方法a还没执行完，于是出现了<strong>死锁</strong>。</li>
</ul></li>
<li>不可重试：获取锁只尝试一次就返回false，没有重试机制</li>
<li>超时释放：锁超时释放虽然可以避免死锁，但如果业务执行耗时较长，也会导致锁释放，存在安全隐患。
<ul>
<li>锁时间设置得太短，业务还么执行完，锁就释放了，导致其他业务也可能在同步执行中；如果设置过长，会导致其他业务等待时间长，阻塞周期长。</li>
</ul></li>
<li>主从一致性：如果Redis提供了主从集群，主从同步存在延迟，当主宕机，如果从并同步主中的锁数据，则会出现锁实现。
<ul>
<li>比如有一个线程在主节点获取了锁（因为是用setnx实现，实际上是一个写操作），尚未将这个写操作同步给从节点时，存在延迟，突然主节点就宕机了，此时会选择一个从节点作为主节点，因为这个从节点尚未完成同步，没有锁这个标识，所以其他线程可以趁虚而入，拿到锁。</li>
</ul></li>
</ul>
<h4 id="介绍">介绍</h4>
<p>Redisson是一个在Redis的基础上实现的Java驻内存数据网络。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包括了各种分布式锁的实现。</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504091048704.png" /></p>
<p>官网：https://redisson.pro/docs/</p>
<h4 id="入门">入门</h4>
<p>1.引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2.配置Redisson客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Redissonclient <span class="title function_">redissonclient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//配置类</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        <span class="comment">//添加redis地址，这里添加了单点的地址，也可以使用config.useClusterServers()添加集群地址</span></span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.150.101:6379&quot;</span>).setPassowrd(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">//创建客户端</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.使用Redisson的分布式锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testRedisson</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//获取锁（可重入），指定锁的名称</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonclient.getLock(<span class="string">&quot;anyLock&quot;</span>);</span><br><span class="line">    <span class="comment">//尝试获取锁，参数分别是，获取锁的最大等待时间（期间会重试），锁自动释放时间，时间单位</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1</span>,<span class="number">10</span>,TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//判断释放政取成功</span></span><br><span class="line">    <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行业务&quot;</span>)；</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="redisson可重入锁原理">Redisson可重入锁原理</h4>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504091928597.png" /></p>
<p>重置锁有效期是为了给后续业务留下时间。</p>
<p>以上存在着多个步骤，要采用lua脚本实现，确保原子性。</p>
<h4 id="redisson分布式锁原理">Redisson分布式锁原理</h4>
<p><code>public boolean tryLock(long waitTime, long leaseTime, TimeUnit unit) throws InterruptedException &#123;&#125;</code></p>
<p>参数：</p>
<ul>
<li>waitTime：<strong>尝试获取锁的最大等待时间</strong>
<ul>
<li>如果锁当前被其他线程持有，调用线程会持续尝试获取锁，直到超过<code>waitTime</code>设定的时长。若在此期间仍未获得锁，则返回<code>false</code>。</li>
</ul></li>
<li>leaseTime：<strong>锁的持有时间</strong>
<ul>
<li>成功获取锁后，锁会在<code>leaseTime</code>时长后自动释放，即使业务逻辑未执行完毕。若<code>leaseTime=-1</code>，则锁不会自动释放，需通过<code>unlock()</code>显式释放，此时Redisson的看门狗机制（WatchDog）会自动续期锁，防止死锁。</li>
</ul></li>
<li>unit：时间单位，用于统一<code>waitTime</code>和<code>leaseTime</code>的时间尺度</li>
</ul>
<h5 id="源码追溯看门狗">源码追溯（看门狗）</h5>
<p>基于jdk1.8</p>
<p><strong>tryLock()原理</strong></p>
<p>RedissonLock.class中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> waitTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.tryLock(waitTime, -<span class="number">1L</span>, unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击tryLock()</p>
<p>:point_down:</p>
<p>RedissonLock.class中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> unit.toMillis(waitTime);  <span class="comment">// 可以看到先将等待时间转换成了毫秒</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> System.currentTimeMillis();  <span class="comment">// 得到当前时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();  <span class="comment">// 得到线程id，其实就是以后锁里的线程标识</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">ttl</span> <span class="operator">=</span> <span class="built_in">this</span>.tryAcquire(waitTime, leaseTime, unit, threadId);  <span class="comment">// 尝试获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        time -= System.currentTimeMillis() - current;</span><br><span class="line">        <span class="keyword">if</span> (time &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = System.currentTimeMillis();</span><br><span class="line">            RFuture&lt;RedissonLockEntry&gt; subscribeFuture = <span class="built_in">this</span>.subscribe(threadId);</span><br><span class="line">            <span class="keyword">if</span> (!subscribeFuture.await(time, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!subscribeFuture.cancel(<span class="literal">false</span>)) &#123;</span><br><span class="line">                    subscribeFuture.onComplete((res, e) -&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="built_in">this</span>.unsubscribe(subscribeFuture, threadId);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    time -= System.currentTimeMillis() - current;</span><br><span class="line">                    <span class="keyword">if</span> (time &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">                        <span class="type">boolean</span> <span class="variable">var20</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">return</span> var20;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="type">boolean</span> var16;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                            ttl = <span class="built_in">this</span>.tryAcquire(waitTime, leaseTime, unit, threadId);</span><br><span class="line">                            <span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">                                var16 = <span class="literal">true</span>;</span><br><span class="line">                                <span class="keyword">return</span> var16;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            time -= System.currentTimeMillis() - currentTime;</span><br><span class="line">                            <span class="keyword">if</span> (time &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                                <span class="built_in">this</span>.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">                                var16 = <span class="literal">false</span>;</span><br><span class="line">                                <span class="keyword">return</span> var16;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            currentTime = System.currentTimeMillis();</span><br><span class="line">                            <span class="keyword">if</span> (ttl &gt;= <span class="number">0L</span> &amp;&amp; ttl &lt; time) &#123;</span><br><span class="line">                                ((RedissonLockEntry)subscribeFuture.getNow()).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                ((RedissonLockEntry)subscribeFuture.getNow()).getLatch().tryAcquire(time, TimeUnit.MILLISECONDS);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            time -= System.currentTimeMillis() - currentTime;</span><br><span class="line">                        &#125; <span class="keyword">while</span>(time &gt; <span class="number">0L</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">this</span>.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">                        var16 = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">return</span> var16;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.unsubscribe(subscribeFuture, threadId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击tryAcquire()</p>
<p>:point_down:</p>
<p>RedissonLock.class中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Long <span class="title function_">tryAcquire</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (Long)<span class="built_in">this</span>.get(<span class="built_in">this</span>.tryAcquireAsync(waitTime, leaseTime, unit, threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击tryAcquireAsync()</p>
<p>:point_down:</p>
<p>RedissonLock.class中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; RFuture&lt;Long&gt; <span class="title function_">tryAcquireAsync</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1L</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果leaseTime有值，就用给的leaseTime值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 无值，就使用默认值，getLockWatchdogTimeout()，看门狗超时时间</span></span><br><span class="line">        RFuture&lt;Long&gt; ttlRemainingFuture = <span class="built_in">this</span>.tryLockInnerAsync(waitTime, <span class="built_in">this</span>.commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">        ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ttlRemaining == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.scheduleExpirationRenewal(threadId);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>追溯getLockWatchdogTimeout()</p>
<p>:point_down:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是在Config.class中</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getLockWatchdogTimeout</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.lockWatchdogTimeout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击lockWatchdogTimeout，以下是在Config.class中</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> lockWatchdogTimeout;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> keepPubSubOrder;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> decodeInExecutor;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> useScriptCache;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> minCleanUpDelay;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> maxCleanUpDelay;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> cleanUpKeysAmount;</span><br><span class="line"><span class="keyword">private</span> NettyHook nettyHook;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> useThreadClassLoader;</span><br><span class="line"><span class="keyword">private</span> AddressResolverGroupFactory addressResolverGroupFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Config</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.transportMode = TransportMode.NIO;</span><br><span class="line">    <span class="built_in">this</span>.lockWatchdogTimeout = <span class="number">30000L</span>;  <span class="comment">// 可以看到，默认时间是30s</span></span><br><span class="line">    <span class="built_in">this</span>.keepPubSubOrder = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">this</span>.decodeInExecutor = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">this</span>.useScriptCache = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">this</span>.minCleanUpDelay = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">this</span>.maxCleanUpDelay = <span class="number">1800</span>;</span><br><span class="line">    <span class="built_in">this</span>.cleanUpKeysAmount = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">this</span>.nettyHook = <span class="keyword">new</span> <span class="title class_">DefaultNettyHook</span>();</span><br><span class="line">    <span class="built_in">this</span>.useThreadClassLoader = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">this</span>.addressResolverGroupFactory = <span class="keyword">new</span> <span class="title class_">DnsAddressResolverGroupFactory</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击tryAcquireAsync中的tryLockInnerAsync</p>
<p>:point_down:</p>
<p>RedissonLock.class中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; RFuture&lt;T&gt; <span class="title function_">tryLockInnerAsync</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> &#123;</span><br><span class="line">    <span class="comment">// 先把锁释放时间记录到本地的一个成员变量，叫做内部锁释放时间</span></span><br><span class="line">    <span class="built_in">this</span>.internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line">    <span class="comment">// 接着执行以下这段脚本</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    	脚本先是判断锁是否存在，如果不存在，就去记录锁的标识并且次数加一，然后设置锁的有效期，返回nil；</span></span><br><span class="line"><span class="comment">    	如果存在，就先判断锁是不是自己的，如果是自己的，锁重试次数加一，并且设置有效期，返回nil；</span></span><br><span class="line"><span class="comment">    	以上两种情况都是获取锁成功的情况，返回的都是nil，失败了返回一个结果，pttl和ttl效果类似，都是获取指定key剩余有效期，只不过ttl返回的是以秒为单位，而pttl返回的是以毫秒为单位。</span></span><br><span class="line"><span class="comment">    	所以失败返回的是锁的剩余有效期。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.evalWriteAsync(<span class="built_in">this</span>.getName(), LongCodec.INSTANCE, command, <span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); return nil; end; if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); return nil; end; return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span>, Collections.singletonList(<span class="built_in">this</span>.getName()), <span class="built_in">this</span>.internalLockLeaseTime, <span class="built_in">this</span>.getLockName(threadId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> CommandBatchService <span class="title function_">createCommandBatchService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.commandExecutor <span class="keyword">instanceof</span> CommandBatchService) &#123;</span><br><span class="line">        <span class="keyword">return</span> (CommandBatchService)<span class="built_in">this</span>.commandExecutor;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">MasterSlaveEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="built_in">this</span>.commandExecutor.getConnectionManager().getEntry(<span class="built_in">this</span>.getName());</span><br><span class="line">        <span class="type">BatchOptions</span> <span class="variable">options</span> <span class="operator">=</span> BatchOptions.defaults().syncSlaves(entry.getAvailableSlaves(), <span class="number">1L</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommandBatchService</span>(<span class="built_in">this</span>.commandExecutor.getConnectionManager(), options);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>往回倒到tryAcquireAsync()中</p>
<p>:point_up:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; RFuture&lt;Long&gt; <span class="title function_">tryAcquireAsync</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1L</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果leaseTime有值，就用给的leaseTime值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 无值，就使用默认值，getLockWatchdogTimeout()，看门狗超时时间</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	从上面的分析知，tryLockInnerAsync返回的是一个剩余有效期，这个结果是封装在Future里面的，因为这个函数是一个异步函数（Async），代表函数执行完代表命令发出去了，结果拿没拿到还不清楚</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        RFuture&lt;Long&gt; ttlRemainingFuture = <span class="built_in">this</span>.tryLockInnerAsync(waitTime, <span class="built_in">this</span>.commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">        ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ttlRemaining == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.scheduleExpirationRenewal(threadId);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 最终返回的也是一个Future</span></span><br><span class="line">        <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>往回倒到tryAcquire()中</p>
<p>:point_up:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Long <span class="title function_">tryAcquire</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">	<span class="comment">// 此处有个get，其实就是阻塞等待Future的结果，等待里面得到的剩余有效期</span></span><br><span class="line">    <span class="keyword">return</span> (Long)<span class="built_in">this</span>.get(<span class="built_in">this</span>.tryAcquireAsync(waitTime, leaseTime, unit, threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>往回倒到tryLock()中</p>
<p>:point_up:</p>
<p>就是最初进来的地方</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> unit.toMillis(waitTime);  <span class="comment">// 可以看到先将等待时间转换成了毫秒</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> System.currentTimeMillis();  <span class="comment">// 得到当前时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();  <span class="comment">// 得到线程id，其实就是以后锁里的线程标识</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">ttl</span> <span class="operator">=</span> <span class="built_in">this</span>.tryAcquire(waitTime, leaseTime, unit, threadId);  <span class="comment">// 尝试获取锁，得到的结果有两种，一种是null，代表获取锁成功；一种是锁的剩余有效期，代表获取锁失败。</span></span><br><span class="line">    <span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        time -= System.currentTimeMillis() - current;</span><br><span class="line">        <span class="keyword">if</span> (time &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = System.currentTimeMillis();</span><br><span class="line">            RFuture&lt;RedissonLockEntry&gt; subscribeFuture = <span class="built_in">this</span>.subscribe(threadId);</span><br><span class="line">            <span class="keyword">if</span> (!subscribeFuture.await(time, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!subscribeFuture.cancel(<span class="literal">false</span>)) &#123;</span><br><span class="line">                    subscribeFuture.onComplete((res, e) -&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="built_in">this</span>.unsubscribe(subscribeFuture, threadId);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    time -= System.currentTimeMillis() - current;</span><br><span class="line">                    <span class="keyword">if</span> (time &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">                        <span class="type">boolean</span> <span class="variable">var20</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">return</span> var20;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="type">boolean</span> var16;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                            ttl = <span class="built_in">this</span>.tryAcquire(waitTime, leaseTime, unit, threadId);</span><br><span class="line">                            <span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">                                var16 = <span class="literal">true</span>;</span><br><span class="line">                                <span class="keyword">return</span> var16;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            time -= System.currentTimeMillis() - currentTime;</span><br><span class="line">                            <span class="keyword">if</span> (time &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                                <span class="built_in">this</span>.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">                                var16 = <span class="literal">false</span>;</span><br><span class="line">                                <span class="keyword">return</span> var16;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            currentTime = System.currentTimeMillis();</span><br><span class="line">                            <span class="keyword">if</span> (ttl &gt;= <span class="number">0L</span> &amp;&amp; ttl &lt; time) &#123;</span><br><span class="line">                                ((RedissonLockEntry)subscribeFuture.getNow()).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                ((RedissonLockEntry)subscribeFuture.getNow()).getLatch().tryAcquire(time, TimeUnit.MILLISECONDS);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            time -= System.currentTimeMillis() - currentTime;</span><br><span class="line">                        &#125; <span class="keyword">while</span>(time &gt; <span class="number">0L</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">this</span>.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">                        var16 = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">return</span> var16;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.unsubscribe(subscribeFuture, threadId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504101618373.png" /></p>
<ul>
<li>可重入：利用hash结构记录线程id和重入次数</li>
<li>可重试：利用信号量和PubSub功能实现等待、唤醒，获取锁失败的重试机制</li>
<li>超时续约：利用watchDog，每隔一段时间（releaseTime/3），重置超时时间</li>
</ul>
<h4 id="redisson的multilock原理">Redisson的multiLock原理</h4>
<p>Redisson分布式锁主从一致性问题：</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504101623204.png" /></p>
<p>每一个节点都获取锁才算成功。</p>
<p><img
src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504101625720.png" /></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://funnytorch.github.io">Torch</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://funnytorch.github.io/2025/03/12/redis-%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E5%AD%A6%E4%B9%A0/">https://funnytorch.github.io/2025/03/12/redis-%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E5%AD%A6%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://funnytorch.github.io" target="_blank">Torch's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/redis/">redis</a></div><div class="post_share"><div class="social-share" data-image="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farticle%2F214ebafad407d4879ef439b124f8d375969f7a68.jpg&amp;refer=http%3A%2F%2Fi0.hdslb.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1637623496&amp;t=e16f6f4016cd1ecf6cadb59f18d702fe" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://lib.baomitu.com/social-share.js/1.0.16/css/share.min.css" media="print" onload="this.media='all'"><script src="https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/04/07/2025-04-07-2025-04-13%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E5%91%A8%E6%8A%A5/" title="2025-04-07-2025-04-13论文阅读周报"><img class="cover" src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farchive%2F06212a062d0da00d93e03824ed971d2f5630c3b0.jpg&amp;refer=http%3A%2F%2Fi0.hdslb.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1673181885&amp;t=1278ca088220515681ecb633cb8819b0" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">2025-04-07-2025-04-13论文阅读周报</div></div></a></div><div class="next-post pull-right"><a href="/2025/02/27/Java%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/" title="Java函数式编程学习"><img class="cover" src="http://hbimg.huaban.com/af85e4b7415940317a168f69f37a3cc0a43af1874f854a-TAz9Y7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java函数式编程学习</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://pic1.imgdb.cn/item/646c2881e03e90d874adf7fc.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Torch</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">75</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">54</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/funnytorch"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/funnytorch" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:torch2147483647@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog<div class="xpand" style="height:200px;"><canvas class="illo" width="800" height="800" style="max-width: 200px; max-height: 200px; touch-action: none; width: 640px; height: 640px;"></canvas></div></div><script src="https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/twopeople1.js"></script><script src="https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/zdog.dist.js"></script><script id="rendered-js" src="https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/twopeople.js"></script><style>.card-widget.card-announcement {
margin: 0;
align-items: center;
justify-content: center;
text-align: center;
}
canvas {
display: block;
margin: 0 auto;
cursor: move;
}</style></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">基础篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E8%AF%86redis"><span class="toc-number">1.1.</span> <span class="toc-text">初识Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#nosql"><span class="toc-number">1.1.1.</span> <span class="toc-text">NoSQL</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E4%B8%8E%E9%9D%9E%E7%BB%93%E6%9E%84%E5%8C%96"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">结构化与非结构化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E4%B8%8E%E9%9D%9E%E5%85%B3%E8%81%94"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">关联与非关联</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">查询方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.1.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86redis"><span class="toc-number">1.1.2.</span> <span class="toc-text">认识Redis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85redis"><span class="toc-number">1.1.3.</span> <span class="toc-text">安装Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redis%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">Redis安装说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E6%9C%BA%E5%AE%89%E8%A3%85redis"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">单机安装Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A41.%E5%AE%89%E8%A3%85redis%E4%BE%9D%E8%B5%96"><span class="toc-number">1.1.3.2.1.</span> <span class="toc-text">步骤1.安装Redis依赖</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A42.%E4%B8%8A%E4%BC%A0%E5%AE%89%E8%A3%85%E5%8C%85%E5%B9%B6%E8%A7%A3%E5%8E%8B"><span class="toc-number">1.1.3.2.2.</span> <span class="toc-text">步骤2.上传安装包并解压</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A43.%E5%90%AF%E5%8A%A8"><span class="toc-number">1.1.3.2.3.</span> <span class="toc-text">步骤3.启动</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%90%AF%E5%8A%A8"><span class="toc-number">1.1.3.2.3.1.</span> <span class="toc-text">默认启动</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E9%85%8D%E7%BD%AE%E5%90%AF%E5%8A%A8"><span class="toc-number">1.1.3.2.3.2.</span> <span class="toc-text">指定配置启动</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF"><span class="toc-number">1.1.3.2.3.3.</span> <span class="toc-text">开机自启</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">Redis命令行客户端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E5%BD%A2%E5%8C%96%E6%A1%8C%E9%9D%A2%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">图形化桌面客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.1.3.4.1.</span> <span class="toc-text">建立连接</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.</span> <span class="toc-text">Redis命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.1.</span> <span class="toc-text">数据结构介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.2.</span> <span class="toc-text">通用命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%BB%A5a%E5%BC%80%E5%A4%B4%E7%9A%84key"><span class="toc-number">2.</span> <span class="toc-text">查询以a开头的key</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E5%91%BD%E4%BB%A4"><span class="toc-number">2.0.1.</span> <span class="toc-text">String命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#key%E7%9A%84%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84"><span class="toc-number">2.0.2.</span> <span class="toc-text">Key的层级结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hash%E5%91%BD%E4%BB%A4"><span class="toc-number">2.0.3.</span> <span class="toc-text">Hash命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set%E5%91%BD%E4%BB%A4"><span class="toc-number">2.0.4.</span> <span class="toc-text">Set命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sortedset%E5%91%BD%E4%BB%A4"><span class="toc-number">2.0.5.</span> <span class="toc-text">SortedSet命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E7%9A%84java%E5%AE%A2%E6%88%B7%E7%AB%AF-jedis"><span class="toc-number">2.1.</span> <span class="toc-text">Redis的Java客户端-Jedis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">2.1.1.</span> <span class="toc-text">快速入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jedis%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-number">2.1.2.</span> <span class="toc-text">Jedis连接池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E7%9A%84java%E5%AE%A2%E6%88%B7%E7%AB%AF-springdataredis"><span class="toc-number">2.2.</span> <span class="toc-text">Redis的Java客户端-SpringDataRedis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-1"><span class="toc-number">2.2.0.1.</span> <span class="toc-text">快速入门</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8"><span class="toc-number">2.2.0.2.</span> <span class="toc-text">数据序列化器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stringredistemplate"><span class="toc-number">2.2.0.3.</span> <span class="toc-text">StringRedisTemplate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hash%E7%BB%93%E6%9E%84%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.0.4.</span> <span class="toc-text">Hash结构操作</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E7%AF%87"><span class="toc-number">3.</span> <span class="toc-text">实战篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95"><span class="toc-number">3.1.</span> <span class="toc-text">短信登录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%95%86%E6%88%B7%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.2.</span> <span class="toc-text">商户查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98"><span class="toc-number">3.2.1.</span> <span class="toc-text">什么是缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="toc-number">3.2.2.</span> <span class="toc-text">缓存更新策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%8A%A8%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">主动更新策略</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%88%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%E5%86%8D%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">3.2.2.1.1.</span> <span class="toc-text">先删除缓存，再操作数据库</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%88%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%8D%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98"><span class="toc-number">3.2.2.1.2.</span> <span class="toc-text">先操作数据库，再删除缓存</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">缓存更新策略的最佳实践</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">3.2.3.</span> <span class="toc-text">缓存穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%95%86%E9%93%BA%E6%9F%A5%E8%AF%A2%E7%9A%84%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">解决商铺查询的缓存穿透问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">3.2.4.</span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">3.2.5.</span> <span class="toc-text">缓存击穿</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E4%BA%92%E6%96%A5%E9%94%81%E6%96%B9%E5%BC%8F%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98"><span class="toc-number">3.2.5.1.</span> <span class="toc-text">基于互斥锁方式解决缓存击穿问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F%E6%96%B9%E5%BC%8F%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98"><span class="toc-number">3.2.5.2.</span> <span class="toc-text">基于逻辑过期方式解决缓存击穿问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80"><span class="toc-number">3.3.</span> <span class="toc-text">优惠券秒杀</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80id%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">3.3.1.</span> <span class="toc-text">全局ID生成器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%A7%92%E6%9D%80%E4%B8%8B%E5%8D%95"><span class="toc-number">3.3.2.</span> <span class="toc-text">实现秒杀下单</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98"><span class="toc-number">3.3.3.</span> <span class="toc-text">超卖问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">3.3.3.1.</span> <span class="toc-text">悲观锁和乐观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">3.3.3.1.1.</span> <span class="toc-text">乐观锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E8%A7%A3%E5%86%B3%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98"><span class="toc-number">3.3.3.1.2.</span> <span class="toc-text">乐观锁解决超卖问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">3.3.3.1.3.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%BA%E4%B8%80%E5%8D%95"><span class="toc-number">3.3.4.</span> <span class="toc-text">一人一单</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">3.3.4.1.</span> <span class="toc-text">并发安全问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">3.4.</span> <span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8Eredis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">3.4.1.</span> <span class="toc-text">基于Redis的分布式锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E5%88%86%E5%B8%83%E5%BC%8F%E8%AF%AF%E5%88%A0%E9%97%AE%E9%A2%98"><span class="toc-number">3.4.2.</span> <span class="toc-text">Redis分布式误删问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">3.4.3.</span> <span class="toc-text">分布式锁的原子性问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">3.4.4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redisson"><span class="toc-number">3.4.5.</span> <span class="toc-text">Redisson</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8Eredis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%BC%98%E5%8C%96"><span class="toc-number">3.4.5.1.</span> <span class="toc-text">基于Redis的分布式锁优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.4.5.2.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A5%E9%97%A8"><span class="toc-number">3.4.5.3.</span> <span class="toc-text">入门</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redisson%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%8E%9F%E7%90%86"><span class="toc-number">3.4.5.4.</span> <span class="toc-text">Redisson可重入锁原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redisson%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86"><span class="toc-number">3.4.5.5.</span> <span class="toc-text">Redisson分布式锁原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E8%BF%BD%E6%BA%AF%E7%9C%8B%E9%97%A8%E7%8B%97"><span class="toc-number">3.4.5.5.1.</span> <span class="toc-text">源码追溯（看门狗）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redisson%E7%9A%84multilock%E5%8E%9F%E7%90%86"><span class="toc-number">3.4.5.6.</span> <span class="toc-text">Redisson的multiLock原理</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/04/14/2025-04-14-2025-04-20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E5%91%A8%E6%8A%A5/" title="2025-04-14-2025-04-20论文阅读周报"><img src="https://pic.imgdb.cn/item/65d6d87d9f345e8d03134f04.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2025-04-14-2025-04-20论文阅读周报"/></a><div class="content"><a class="title" href="/2025/04/14/2025-04-14-2025-04-20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E5%91%A8%E6%8A%A5/" title="2025-04-14-2025-04-20论文阅读周报">2025-04-14-2025-04-20论文阅读周报</a><time datetime="2025-04-14T11:52:50.000Z" title="发表于 2025-04-14 19:52:50">2025-04-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/07/2025-04-07-2025-04-13%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E5%91%A8%E6%8A%A5/" title="2025-04-07-2025-04-13论文阅读周报"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farchive%2F06212a062d0da00d93e03824ed971d2f5630c3b0.jpg&amp;refer=http%3A%2F%2Fi0.hdslb.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1673181885&amp;t=1278ca088220515681ecb633cb8819b0" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2025-04-07-2025-04-13论文阅读周报"/></a><div class="content"><a class="title" href="/2025/04/07/2025-04-07-2025-04-13%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E5%91%A8%E6%8A%A5/" title="2025-04-07-2025-04-13论文阅读周报">2025-04-07-2025-04-13论文阅读周报</a><time datetime="2025-04-07T05:59:32.000Z" title="发表于 2025-04-07 13:59:32">2025-04-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/12/redis-%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E5%AD%A6%E4%B9%A0/" title="redis-黑马点评学习"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farticle%2F214ebafad407d4879ef439b124f8d375969f7a68.jpg&amp;refer=http%3A%2F%2Fi0.hdslb.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1637623496&amp;t=e16f6f4016cd1ecf6cadb59f18d702fe" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="redis-黑马点评学习"/></a><div class="content"><a class="title" href="/2025/03/12/redis-%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E5%AD%A6%E4%B9%A0/" title="redis-黑马点评学习">redis-黑马点评学习</a><time datetime="2025-03-12T06:09:45.000Z" title="发表于 2025-03-12 14:09:45">2025-03-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/27/Java%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/" title="Java函数式编程学习"><img src="http://hbimg.huaban.com/af85e4b7415940317a168f69f37a3cc0a43af1874f854a-TAz9Y7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java函数式编程学习"/></a><div class="content"><a class="title" href="/2025/02/27/Java%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/" title="Java函数式编程学习">Java函数式编程学习</a><time datetime="2025-02-27T08:28:58.000Z" title="发表于 2025-02-27 16:28:58">2025-02-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/26/Java%E4%B8%ADprotected%E8%AF%A6%E8%A7%A3%E2%80%94%E2%80%94%E4%BB%A5clone%E4%B8%BA%E4%BE%8B/" title="Java中protected详解——以clone为例"><img src="https://gd-hbimg.huaban.com/5aea5ac9e3581ef38e55f0a1a170e33bad48bf9f15ebac-U9qNbN" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java中protected详解——以clone为例"/></a><div class="content"><a class="title" href="/2025/02/26/Java%E4%B8%ADprotected%E8%AF%A6%E8%A7%A3%E2%80%94%E2%80%94%E4%BB%A5clone%E4%B8%BA%E4%BE%8B/" title="Java中protected详解——以clone为例">Java中protected详解——以clone为例</a><time datetime="2025-02-26T09:03:54.000Z" title="发表于 2025-02-26 17:03:54">2025-02-26</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>再看看那个光点，它就在这里，这是家园，这是我们 —— 你所爱的每一个人，你认识的一个人，你听说过的每一个人，曾经有过的每一个人，都在它上面度过他们的一生✨</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://stellarium.org/">点击开启星辰之旅</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/about/">关于作者</a><a href="/comments/">留点什么</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li><li><a href="/archives/">文章归档</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"></div></div></div><div class="copyright"><span><b>&copy;2020 - 2025</b></span><span><b>&nbsp;&nbsp;By Torch</b></span></div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo"><img src="https://img.shields.io/badge/Frame-Hexo-blue?logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly"><img src="https://img.shields.io/badge/Theme-Butterfly-purple?logo=bitcoin" alt=""/></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20226665" style="margin-inline:5px" title="本站已加入萌ICP豪华套餐，萌ICP备20226665号"><img src="https://sourcebucket.s3.ladydaily.com/badge/萌ICP备-20226665-fe1384.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://cn.aliyun.com/" style="margin-inline:5px" title="本网站大部分图片在阿里云对象存储"><img src="https://img.shields.io/badge/Bucket-%E9%98%BF%E9%87%8C%E4%BA%91-orange?logo=academia" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本网站源码由Github提供存储仓库"><img src="https://img.shields.io/badge/Source-Github-black?logo=github" alt=""/></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20240421" style="margin-inline:5px" title="本站已加入萌ICP豪华套餐，萌ICP备20240421号"><img src="https://img.shields.io/badge/%E8%90%8CICP%E5%A4%87-20240421-F2218A?logo=data%3Aimage%2Fpng%3Bbase64%2CiVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAARzQklUCAgICHwIZIgAABHOSURBVHic7ZtpmFTF1cd%2FdXuf6VmYnhlAdiQsGkEWAQEVNb4KGsW8btGAxo1FFAIuBAyLa1BQUFGRqCB5RY3mSWIUI0beyCaLgKjI4gayjszWPT3T6618OLfn9gzTyMCgXzzP00%2FfW1Vd95z%2FPVudqoaf6Cf6iX4M0lo79P%2Fvv09vLL1fa%2B34sfhw%2FtAP1Fo7uHf1dJo9kk9F6U2goUXLfP3g2kom952mlEr%2BkPyoH%2BIhWmtlzv9slvHEyuZs%2FdLA5R5GtseHw5ABCRPC0RoS8b%2BZvbuYxvhBB%2FlN5zuVUvpE83bCANBaK5bufdR8%2FINWxrJPweBi%2FJ4cXA5QKjXI4iLtPpaAUDQEjre4rCdMHLSPs4pPGBhNDoD%2BtPI%2Bc87KLsaijyBecxHZ7ly8LutpSoQ0NVTHIJqQdq8LfC4wlD1GA5E4VEeD%2BHLe4Za%2BmOPP2u3o6L2rKfltMgCS01fPMOatPoXvDg7G6ys8XCANkQRUR9HZOaiRA9B3D0JVJ9AzP0C9sBbi1ZDtITNgkUratllmjh2w1XF3n2lNwfdxAaBf%2BHwqT67qwaYd4HSdhd9ThMM4XKWrYqANuKIPjD8TPbAYhbzkdAb0u3tRc1fD25vBQMBw1zOZRBKqYt%2BRTKzQA09F3T7wY3XNyfcdqwyNBkC%2Ft28cc1cP5s2PQDEAv6cYt%2FNwJqvjEI9D%2F1Pg9n5wbRdb4J1hmLsG5q0Evxs9eiBq3JnQyi1TAOpPW%2BHJ1bBlJ7jdkOXmMHCjCaiKlIBztb66L%2BqO%2Fh%2BpgcUPNDkA%2BovqsfrxlReoBWshFu5JlqcNXpf8Ol1Na2IQiUKrVujb%2B6PG9wWPNUkUmLse5q6CfQfAcECXIthZKqYSi8HJbWD8IPTYHrXM6QoNj61GzVsNZYfA5xV%2FoeqZV00camIHycldy%2BgB%2F1aPDH7iuAHQL24dw6R3hnLwwGl4PW3xuTM5KvBmw0390BPOgo5eW8Vf3oF%2BfBVqwzZwWW9SKaioAv1HGPZ%2FsHQH5LghnoRwDJIJOOc09PgBqGEdhBeAT4Lw2ErU4vWQjEK2uwF%2FYUJ17FuisS20bQNP%2FHKpGtZ%2B3rEBkDvzGczqUXhch9t1OAamQl%2FaEzV%2BAJzb0mZ05UHUnDXwxkZQSfC7wW3lXKVhwICnfwmj%2B0FlBNo8AqFqyMsGlyNNvaNguOG6vjC%2BP%2FQqqDUj%2Fc%2FdqLmr4L0t4HAIGPVDbHUU2rWer7aNHHVsADD5GQJZo2rRDUUgFkP37Iy6YyD6hq61E%2BhdNai5a2HBGqgKQpYHvE5bVQEOheG7yVCY3fADT5kL%2B4IiSEqIWvWOQkEARg9EjzsDVeSyAX96C%2BrJNbDtK%2FB6BQylRBvCzFfRPzQeAP1F9V10um8iAX9zAEIR9F1DUJMGoP21CMGcjahp70HoIHiyRcWNNKHTKZqAkwtg09jD%2B55dB6P%2FAQFfw7%2FVGpKmhMNYHN2tPWrcIPTIn9svoSSBmr4cFq4UPgBKQ%2FMVMzMCYGTqYHtJezCa1779uAP1wADwg3r9S9SgxSjjHtSEl2DDjXBZLzAzzibkccLm%2FTBlWd32kjCMfiWz8CDtTgfkeMHnRX2%2BG8YsQanfw4WvwNI9UOxEP32BaEvqN3C53lw2qfEAfFMOTosZU0OLPAD0W7vgyqdgw07pCxRB50J449fQKhdiSYibdppbnxwGdGxWt604G3BlZAWQ9UJ5DZSGYEhnKJkifAX8sGobDH0UtlSINrj9aWm2o9j8urxtowEwvw2CYXUnTWhdIPPtqQS80LcNfD0JDk2xBfv6TqiaJgIlMwCgEB%2Fw0iZwT4URr4tpeLxHFr6FH16%2BCuZcCm9cC0XZQAwqo1Yk8Fu8AYU5Ak6Kr92VGafOuBw29lWBI00Dii3HdaAKnE74aF%2FD6jr5XfiqHAp8DU%2Bc74MrXpZrvwde%2FxQWb4RAdmb1dyjYfgiuOq1uu54Fs1bAve%2BBQ6H3BiVCtMhGfWEJbSiM76oyiXkEEyivEmcGYGp0sQikS6rAaYDHAe0byEAfXg55nsPb0ynfJx%2BnIR670J9ZeJA%2BtwOufe3wvlyvvCBDoUrCMrwwRyIAiAyHqjNOnRmAYMRmytSoPAFAVVRLu8Ogjt2W1cj30G7iA5qa4kkY1q1u221vwsjXIc8rglZEpD3HYztkBQQTGafNXBGqTthBUgM%2BK6xUJW3YDDes%2FAb%2BdwmUlMKlp8PBKtt5NiVpoFMAHlslWjPyDPj0APgt01Sqdnmt%2FU5UWq3BrM5sApkBqF%2BYSgkVT3NuBT4453lJYwPN4P2vZJzzBJT4AlnQ52nxB4k4rP0WdlWAK02JLd5UepsCzMyKnhmAw16ibrg93dl5T3CJMZBlseKFVz8RP%2BSoJyygta7HZuYyY2aOnfUmjlvXblWLxY9GSkFWvbxBa3CltDS9HXBlzjEyA%2BB32YIqhQ7XCKq5bjvJCEUlR8hvIOTFkhCsgYJsO5rUp0hC6gam9YZSixp3AyYUikI0mkEKl5iGT6KPCkbtZ2qN4c%2FKKGZmAPJ8djKhQJXJw3WBH2VqYejus%2BC05nD1q7Z6poTvWADv3witZtr1vhSZGspCMOhkGNsferWEhIb1e2DmCth6oG5eEIrCXWfB%2Fb9omNclH8O1f4YCAUBX1KBqIxiQm9knZQTALM7CSM%2BmSsSTqpZZIkA8Ab%2FtDR2awfDXRRNS9hiKwtRzoZkPep8EHx%2BQdQBIfC4Lw39Gwtkd6j60WxGM6AmLN8GIVyCQa3n3JAxuL2O%2BrbQSNEvALJcV%2FjScJOk6B9NzGBMKcxsPAK2biVAgk%2B0JAqBb5aGSGjChtfXAG3vDix9JZqc16CRcfor0dSyQrNGD9JWFYOtE6FYMH%2B%2BH6%2F4Cn%2B0Vgfq1h79eB8N7SoIzbBEEcmSeqGUmbe9D8o80jXK5ADe0E0HVgZCdxSY1tPOTiTLHh%2Fb5dj7vMGB3qVx3LbZs1mGHoFF9IRKT60gCLk5LWH4WkFwepDg64RwR%2Fp0dcPos2F0hbzqQA58ehFYzYMchuKwbDD1F5ksntx8KciTfT31yPfJCfhYQt1VeKesYDZhmjPZFkUYDYHQtimAmRSpDQVg0QHUvAJKy8gMIRqF7C8jxicaEYzCmnz1R5yJbk6IRmD1Uroc8DwUFYhqpoonPBXl50PMpGfPoRRCu5%2FjiSfExsYT9SZqAC1q4Ufvj2GFAA%2BafOaf57xsNAL0LJoNejNa2M9pcJtrnzJGsDODOpfJ9Ux8IxwEThnYRO%2F6qDLoWih0mTGhhLYOf3wDK1XB0cDmklLXiGzilWMBOj7udC6WocnJAPp0Lpb2d1G30xn2grNKYBnDFlVIZwscRAFBKRcnKj9dGAqcTvXq3XPdoDe0s%2B3%2F1E6nd3d4fYlVwRXdpX7BBlqFdCgUUU0NLy54%2F%2F84uezXIlRO%2BsEwuL6cuANvGw%2BaxsPE2%2BawfA%2BV%2FEDAAtXqXPXcyCe1bZH4O37c73LsVbPpKfIDbgVr%2BNYw5HQZ3AI9l88EgPL1OQiJuuOUMaV%2BxFXb1kbEgPqva%2Bk0gyw6xDZFpygIHoLKGOg5vzmrxPSmtdDvg7e1w%2Balyv%2FwbyRBBTOXMtvDNMQJgnt8RY%2B1OKTh4HPCuVQUa2hl2fGuN0rBgvQBwaz%2F4n07w1nbAYb%2FFolxZIW4%2FKPfX9oDJ%2FwTtOXwZrDUQg1%2BdKkkSybps%2Fu7vYKSZjwaSYXjuGqkYr9kJBRZ40USUc9tXsySzjJl9AGBc3LWSWCyM1uJVg4dgfwLOOwkGdIIDIcAFXxyEsmqYP0x%2B%2BOw6UF7Y9p3cnxwQR2U44bVPoF0%2BXNVbSuTppTOtoTQIM4bI%2FawVsiuUTm6vXU%2FI90nJvWUbKHSg1pYCCQFHazBjL3PLafccUcYjddInMAXcS2odocsjpSyA7gEJWxjS%2Fsw6%2B3f%2F%2FEwY23FI7js2EyeY54Ub3pC2V6%2BBEb2gtELK5YfCcn3vBTD1PAl%2F05ZJbpFOsRqpPZRVy6cyCMP7SN%2BfN4HXAixpQl5hQikV5wh0RBNQSiX1kNdMPvhM6gFZLpi%2FFu6x7HxHqSyaslxiBlMGw5vbZFqXIf0gjjCVKRoKOj8GOybAoitEa5bukPGXdLUfftIfITfLVvVUYrPwGmsDxBoXScBl3UX9F66XUJpqH94PFhxJwqM5InNz73KWbqrC5%2FbjdMDXe%2BDrKHTwwKZ9AoDTgL0hmPQvWLIF8r2iMRGrFNU6z3bkPhfsC0HWdHj%2Bcvh1DztrBJj3IYx9UzLB1KLIoSSJAri%2BV4NsqhUlsiETsCrCkUiYm3uVfx8A31u60VobqKkLKHDfiGFIYnJlP1g0FP3UFtTtr0hNT2txWh6nvZROmlIjqIiIlqQ7vKQpFV0zBs1yxElWhcHpFuHTcwStJeFqnQuxtHJbSQj%2BfisMaYM%2Bfwlq7XbR1EQStPtFKu65WSl1xPrckX0AoJQyuWngIcLRECAPeGmV9I3tLpuiyaQIl%2B2uW0dwGKKK9YVP9RX4JA0GMYFArji2%2BgmSUpLultdIphmOQUW1ZJJD2kBJAvX%2Bx%2FZGaVWsigmDD32f8EcFAAB%2FunAS0egbEg2UhMSx70vfC1dDeT1vXl%2FQ76v4OoyjG%2Bd0CMAOBeFqeP066bvlTdmLTO1iJZJvMLXfEb1%2Fio4KAKWU5tyeJURiogV%2BD8x7F0LArztBtw72eZ8fgqpjcF5PGFQshy3%2BsSataBsJMWJQydEeqjrq8q3WWqHuXkggb4Q4uBi6WzvUut%2BigxqVNwUKsuzdpBNFSRMqEmhzujDf%2FkkoL5ftd62hNLwY%2FdD1RwvAUXOrlNLmVYN2EYqWAeBxodZvR7%2BwDZWr0K%2FeBGXBzKbQFKQ1lAdh1VgRfvoa2L3fPntQURM0J160qzFH6hpdwNfc%2BxIFnuEYhlXaCqMPzIDmLtTED%2BCxt2VtfyR7PhbSGkor0HOHo%2B7oDlsqocdDdtUokYSo8ZaqufeSxkzbeH39y43fUBasrHWIeV5Up1nSN%2Fts9PWDZAe3KTXBEp7JvxLhI0CP2RI%2BU46vIlhpLh%2F1RWOnbjQA6sqOU7m0%2F4tU1lQA4HKCjqJazZH%2BhZfAhKFQWmnvzx0PJU0R%2FrHfwINnyo5X8cOQ65TIIXZfwdghCx39C8c3Wp5j5Uu3fHwOoYrr8brzASli5DeDvRYPr30JVz8vESNV9WnUA6yjMdVJWD4WBjeHKOjih1FmzI75oWgFXVovUltubbTwcLwHJZ0z5pDFDbidUh2piQFu2HkXtHRBhQl958POXdDMX3cXJ%2BOk1lGYiio4oxt8eIPo6WchOG0W5DhspxeJVuLOXqTK7hl3rDIcV8xSiWnjCSYWEUvIZrzPDc4EnDQVFmyFfAN2jEYvvAFCVjk8kWzYP6QOWJaG0QkH%2Bm9jYN0NaAN4aD38%2FAHId9YVPul56XiEhyY6K6y99z2II3krXlehnM6S8rfu3Rm1%2FEawKmHM2QxT34FQpRyD9bgAbZ81LCpCz7wYfmudPtsThfNegJ27ZZGTcnjhSCnZOc%2Bp0nsmHy%2FvTRardIcnHmTX%2FpE0yw7UMhpNQFUNjLoAnjlfxgEs24uauwbe2gw40Ff2gt8NgDOLhKkw6JvfRL2yEnKyLKCwHF5VKb1%2BNl9tvGlKU%2FDdpME6OfztB4zFy0fRLCeAI%2B2sX1VUNjZGDETffz6qbcMnSPTnIbj336i%2Ffij7fKlTpSDmUREMMvHSp9Tss5tEeGhiAAD0vw88wJD5XUnGLiDfl1v35GYMaqLoTm1RY%2Fqhb%2BkNNUnUcxvg2Q9hz37ISjsLDBJKy2uC5OYs4z9jdqvT8yY0Jb8n4CiH9ReZce%2FPNp5Y1hqP60L8nrpAxK3T5AlrAeVyytt2GnUPQIeiQeLmv5j%2Byz1M6z%2FxRPxr5IQAkCKttWLE27NZvOIknI6h%2BD05hx15h7r3SROCkRCmepvbBu%2FnqV9MOJH%2FHTqhAKRIa63MGR%2FONh7%2FoAWVpZfg9ebgc9Y9h1gTh2ikhubN%2F85d5%2B5nYq8T8sbr0w8CQIq01op1h2abz28oMl752CBYdjGYb1HY0uTa0zFv7VNpnJo77of%2B69yPQlprh%2F6yatKP%2BafJn%2Bgn%2Bon4L4cd%2F2hQhc%2BBAAAAAElFTkSuQmCC" alt=""/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.19/fancybox/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script async src="/js/title.js"></script><script defer src="/js/runtime.js"></script><script src="/js/sun_moon.js" async></script><script async src="/js/fps.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/fireworks.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = '0671ba19028145b2a6a05408f0b01332';
  var gaud_map_key = 'b5a4cd020508da8ff9992038833bd1ba';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '112.982279,28.19409';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><!-- hexo injector body_end end --></body></html>