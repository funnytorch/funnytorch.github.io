<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>redis-黑马点评学习 | Torch's blog</title><meta name="author" content="Torch"><meta name="copyright" content="Torch"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基础篇初识RedisNoSQLNoSql可以翻译做Not Only Sql（不仅仅是SQL），或者是No Sql（非Sql的）数据库。是相对于传统关系型数据库而言，有很大差异的一种特殊的数据库，因此也称之为非关系型数据库。 结构化与非结构化结构化：传统关系型数据库是结构化数据，每一张表都有严格的约束信息：字段名.字段数据类型.字段约束等等信息，插入的数据必须遵守这些约束。（缺点：表不能随意">
<meta property="og:type" content="article">
<meta property="og:title" content="redis-黑马点评学习">
<meta property="og:url" content="https://funnytorch.github.io/2025/03/12/redis-%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Torch&#39;s blog">
<meta property="og:description" content="基础篇初识RedisNoSQLNoSql可以翻译做Not Only Sql（不仅仅是SQL），或者是No Sql（非Sql的）数据库。是相对于传统关系型数据库而言，有很大差异的一种特殊的数据库，因此也称之为非关系型数据库。 结构化与非结构化结构化：传统关系型数据库是结构化数据，每一张表都有严格的约束信息：字段名.字段数据类型.字段约束等等信息，插入的数据必须遵守这些约束。（缺点：表不能随意">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farticle%2F214ebafad407d4879ef439b124f8d375969f7a68.jpg&refer=http%3A%2F%2Fi0.hdslb.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637623496&t=e16f6f4016cd1ecf6cadb59f18d702fe">
<meta property="article:published_time" content="2025-03-12T06:09:45.000Z">
<meta property="article:modified_time" content="2025-05-19T06:38:53.077Z">
<meta property="article:author" content="Torch">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farticle%2F214ebafad407d4879ef439b124f8d375969f7a68.jpg&refer=http%3A%2F%2Fi0.hdslb.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1637623496&t=e16f6f4016cd1ecf6cadb59f18d702fe"><link rel="shortcut icon" href="https://pic1.imgdb.cn/item/646c285ce03e90d874adadbd.png"><link rel="canonical" href="https://funnytorch.github.io/2025/03/12/redis-%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E5%AD%A6%E4%B9%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.19/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'redis-黑马点评学习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-05-19 14:38:53'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/modify.css"><link rel="stylesheet" href="https://npm.elemecdn.com/ethan4116-blog/lib/css/plane_v2.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><span id="fps"></span><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://pic1.imgdb.cn/item/646c2881e03e90d874adf7fc.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">87</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">60</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farticle%2F214ebafad407d4879ef439b124f8d375969f7a68.jpg&amp;refer=http%3A%2F%2Fi0.hdslb.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1637623496&amp;t=e16f6f4016cd1ecf6cadb59f18d702fe')"><nav id="nav"><span id="blog-info"><a href="/" title="Torch's blog"><span class="site-name">Torch's blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">redis-黑马点评学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-12T06:09:45.000Z" title="发表于 2025-03-12 14:09:45">2025-03-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-19T06:38:53.077Z" title="更新于 2025-05-19 14:38:53">2025-05-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E5%AD%A6%E4%B9%A0/">Java学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">22.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>82分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="redis-黑马点评学习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><meta name="referrer" content="no-referrer" />



<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="初识Redis"><a href="#初识Redis" class="headerlink" title="初识Redis"></a>初识Redis</h2><h3 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h3><p><strong>NoSql</strong>可以翻译做Not Only Sql（不仅仅是SQL），或者是No Sql（非Sql的）数据库。是相对于传统关系型数据库而言，有很大差异的一种特殊的数据库，因此也称之为<strong>非关系型数据库</strong>。</p>
<h4 id="结构化与非结构化"><a href="#结构化与非结构化" class="headerlink" title="结构化与非结构化"></a>结构化与非结构化</h4><p>结构化：传统关系型数据库是结构化数据，每一张表都有严格的约束信息：字段名.字段数据类型.字段约束等等信息，插入的数据必须遵守这些约束。（缺点：表不能随意修改）</p>
<p>非结构化：对数据库格式没有严格约束，往往形式松散，自由。</p>
<ul>
<li>键值型：Redis</li>
<li>文档型（字段约束非常松散）：MongoDB</li>
<li>列类型：HBase</li>
<li>图格式：Neo4j</li>
</ul>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503121420204.png" alt=""></p>
<h4 id="关联与非关联"><a href="#关联与非关联" class="headerlink" title="关联与非关联"></a>关联与非关联</h4><p>传统数据库的表与表之间往往存在关联，例如外键。</p>
<p>而非关系型数据库不存在关联关系，要维护关系要么靠代码中的业务逻辑，要么靠数据之间的耦合：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  id<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  name<span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">  orders<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">       id<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">       item<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">	 id<span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span> title<span class="punctuation">:</span> <span class="string">&quot;荣耀6&quot;</span><span class="punctuation">,</span> price<span class="punctuation">:</span> <span class="number">4999</span></span><br><span class="line">       <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">       id<span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">       item<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">	 id<span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span> title<span class="punctuation">:</span> <span class="string">&quot;小米11&quot;</span><span class="punctuation">,</span> price<span class="punctuation">:</span> <span class="number">3999</span></span><br><span class="line">       <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>此处要维护“张三”的订单与商品“荣耀”和“小米11”的关系，不得不冗余的将这两个商品保存在张三的订单文档中，不够优雅。还是建议用业务来维护关联关系。</p>
<h4 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h4><p>传统关系型数据库会基于Sql语句做查询，语法有统一标准；</p>
<p>而不同的非关系数据库查询语法差异极大，五花八门各种各样。</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503121424079.png" alt=""></p>
<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>传统关系型数据库能满足事务ACID的原则。</p>
<p>而非关系型数据库往往不支持事务，或者不能严格保证ACID的特性，特性：BASE，只能实现基本的一致性。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>SQL</th>
<th>NoSQL</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>数据结构</strong></td>
<td>结构化</td>
<td>非结构化</td>
</tr>
<tr>
<td><strong>数据关联</strong></td>
<td>关联的</td>
<td>非关联的</td>
</tr>
<tr>
<td><strong>查询方式</strong></td>
<td>SQL查询</td>
<td>非SQl</td>
</tr>
<tr>
<td><strong>事务特性</strong></td>
<td>ACID</td>
<td>BASE</td>
</tr>
<tr>
<td><strong>存储方式</strong></td>
<td>磁盘</td>
<td>内存</td>
</tr>
<tr>
<td><strong>扩展性</strong></td>
<td>垂直</td>
<td>水平</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>1）数据结构固定<br />2）相关业务对数据安全性、一致性要求较高</td>
<td>1）数据结构不固定<br />2）对一致性、安全性要求不高<br />3）对性能要求</td>
</tr>
</tbody>
</table>
</div>
<h3 id="认识Redis"><a href="#认识Redis" class="headerlink" title="认识Redis"></a>认识Redis</h3><p> 特征：</p>
<ul>
<li>键值（key-value）型，value支持多种不同数据结构，功能丰富</li>
<li>单线程，每个命令具备原子性</li>
<li>低延迟，速度快（基于内存、IO多路复用、良好的编码）</li>
<li>支持数据持久化</li>
<li>支持主从集群、分片集群</li>
<li>支持多语言客户端（java、Python、c等）</li>
</ul>
<h3 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h3><h4 id="Redis安装说明"><a href="#Redis安装说明" class="headerlink" title="Redis安装说明"></a>Redis安装说明</h4><p>大多数企业都是基于Linux服务器来部署项目，而且Redis官方也没有提供Windows版本的安装包。因此课程中我们会基于Linux系统来安装Redis.</p>
<p>此处选择的Linux版本为CentOS 7</p>
<p>Redis的官方网站地址：<a target="_blank" rel="noopener" href="https://redis.io/">https://redis.io/</a></p>
<h4 id="单机安装Redis"><a href="#单机安装Redis" class="headerlink" title="单机安装Redis"></a>单机安装Redis</h4><h5 id="步骤1-安装Redis依赖"><a href="#步骤1-安装Redis依赖" class="headerlink" title="步骤1.安装Redis依赖"></a>步骤1.安装Redis依赖</h5><p>Redis是基于C语言编写的，因此首先需要安装Redis所需要的gcc依赖：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc tcl</span><br></pre></td></tr></table></figure>
<h5 id="步骤2-上传安装包并解压"><a href="#步骤2-上传安装包并解压" class="headerlink" title="步骤2.上传安装包并解压"></a>步骤2.上传安装包并解压</h5><p>然后将Redis安装包上传到虚拟机的任意目录：</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503131441425.png" alt=""></p>
<p>例如，放到了/usr/local/src 目录：</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503131441437.png" alt=""></p>
<p>解压缩：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf redis-6.2.6.tar.gz</span><br></pre></td></tr></table></figure>
<p>解压后：</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503131441444.png" alt=""></p>
<p>进入redis目录：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> redis-6.2.6</span><br></pre></td></tr></table></figure>
<p>运行编译命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>如果没有出错，应该就安装成功了。</p>
<p>默认的安装路径是在 <code>/usr/local/bin</code>目录下：</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503131441445.png" alt=""></p>
<p>该目录以及默认配置到环境变量，因此可以在任意目录下运行这些命令。其中：</p>
<ul>
<li>redis-cli：是redis提供的命令行客户端</li>
<li>redis-server：是redis的服务端启动脚本</li>
<li>redis-sentinel：是redis的哨兵启动脚本</li>
</ul>
<h5 id="步骤3-启动"><a href="#步骤3-启动" class="headerlink" title="步骤3.启动"></a>步骤3.启动</h5><p>redis的启动方式有很多种，例如：</p>
<ul>
<li>默认启动</li>
<li>指定配置启动</li>
<li>开机自启</li>
</ul>
<h6 id="默认启动"><a href="#默认启动" class="headerlink" title="默认启动"></a>默认启动</h6><p>安装完成后，在任意目录输入redis-server命令即可启动Redis：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure>
<p>如图：</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503131441451.png" alt=""></p>
<p>这种启动属于<code>前台启动</code>，会阻塞整个会话窗口，窗口关闭或者按下<code>CTRL + C</code>则Redis停止。不推荐使用。</p>
<h6 id="指定配置启动"><a href="#指定配置启动" class="headerlink" title="指定配置启动"></a>指定配置启动</h6><p>如果要让Redis以<code>后台</code>方式启动，则必须修改Redis配置文件，就在我们之前解压的redis安装包下（<code>/usr/local/src/redis-6.2.6</code>），名字叫redis.conf：</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503131441455.png" alt=""></p>
<p>我们先将这个配置文件备份一份：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp redis.conf redis.conf.bck</span><br></pre></td></tr></table></figure>
<p>然后修改redis.conf文件中的一些配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监听的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span></span><br><span class="line"><span class="attr">bind</span> <span class="string">0.0.0.0</span></span><br><span class="line"><span class="comment"># 守护进程，修改为yes后即可后台运行</span></span><br><span class="line"><span class="attr">daemonize</span> <span class="string">yes </span></span><br><span class="line"><span class="comment"># 密码，设置后访问Redis必须输入密码</span></span><br><span class="line"><span class="attr">requirepass</span> <span class="string">123321</span></span><br></pre></td></tr></table></figure>
<p>Redis的其它常见配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监听的端口</span></span><br><span class="line"><span class="attr">port</span> <span class="string">6379</span></span><br><span class="line"><span class="comment"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">.</span></span><br><span class="line"><span class="comment"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span></span><br><span class="line"><span class="attr">databases</span> <span class="string">1</span></span><br><span class="line"><span class="comment"># 设置redis能够使用的最大内存</span></span><br><span class="line"><span class="attr">maxmemory</span> <span class="string">512mb</span></span><br><span class="line"><span class="comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span></span><br><span class="line"><span class="attr">logfile</span> <span class="string">&quot;redis.log&quot;</span></span><br></pre></td></tr></table></figure>
<p>启动Redis：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入redis安装目录 </span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/src/redis-6.2.6</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure>
<p>停止服务：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，</span></span><br><span class="line"><span class="comment"># 因为之前配置了密码，因此需要通过 -u 来指定密码</span></span><br><span class="line">redis-cli -u 123321 shutdown</span><br></pre></td></tr></table></figure>
<h6 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h6><p>我们也可以通过配置来实现开机自启。</p>
<p>首先，新建一个系统服务文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/systemd/system/redis.service</span><br></pre></td></tr></table></figure>
<p>内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=redis-server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<p>然后重载系统服务：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure>
<p>现在，我们可以用下面这组命令来操作redis了：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start redis</span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">systemctl stop redis</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart redis</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">systemctl status redis</span><br></pre></td></tr></table></figure>
<p>执行下面的命令，可以让redis开机自启：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> redis</span><br></pre></td></tr></table></figure>
<h4 id="Redis命令行客户端"><a href="#Redis命令行客户端" class="headerlink" title="Redis命令行客户端"></a>Redis命令行客户端</h4><p>Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli [options] [commonds]</span><br></pre></td></tr></table></figure>
<p>其中常见的options有：</p>
<ul>
<li><code>-h 127.0.0.1</code>：指定要连接的redis节点的IP地址，默认是127.0.0.1</li>
<li><code>-p 6379</code>：指定要连接的redis节点的端口，默认是6379</li>
<li><code>-a 123321</code>：指定redis的访问密码 </li>
</ul>
<p>其中的commonds就是Redis的操作命令，例如：</p>
<ul>
<li><code>ping</code>：与redis服务端做心跳测试，服务端正常会返回<code>pong</code></li>
</ul>
<p>不指定commonds时，会进入<code>redis-cli</code>的交互控制台：</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503131502243.png" alt=""></p>
<h4 id="图形化桌面客户端"><a href="#图形化桌面客户端" class="headerlink" title="图形化桌面客户端"></a>图形化桌面客户端</h4><p>GitHub上的大神编写了Redis的图形化桌面客户端，地址：<a target="_blank" rel="noopener" href="https://github.com/uglide/RedisDesktopManager">https://github.com/uglide/RedisDesktopManager</a></p>
<p>不过该仓库提供的是RedisDesktopManager的源码，并未提供windows安装包。</p>
<p>在下面这个仓库可以找到安装包：<a target="_blank" rel="noopener" href="https://github.com/lework/RedisDesktopManager-Windows/releases，然后安装">https://github.com/lework/RedisDesktopManager-Windows/releases，然后安装</a></p>
<h5 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h5><p>点击左上角的<code>连接到Redis服务器</code>按钮：</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503131503909.png" alt=""></p>
<p>在弹出的窗口中填写Redis服务信息：</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503131503911.png" alt=""></p>
<p>点击测试连接，看连接是否成功。</p>
<blockquote>
<p>注意：需要先设置虚拟机的防火墙</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --permanent --add-port=6379/tcp </span><br><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure>
</blockquote>
<p>点击确定后，在左侧菜单会出现这个链接：</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503131503916.png" alt=""></p>
<p>点击即可建立连接了：</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503131503919.png" alt=""></p>
<p>Redis默认有16个仓库，编号从0至15.  通过配置文件可以设置仓库数量，但是不超过16，并且不能自定义仓库名称。</p>
<p>如果是基于redis-cli连接Redis服务，可以通过select命令来选择数据库：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择 0号库</span></span><br><span class="line">select 0</span><br></pre></td></tr></table></figure>
<h2 id="Redis命令"><a href="#Redis命令" class="headerlink" title="Redis命令"></a>Redis命令</h2><h3 id="数据结构介绍"><a href="#数据结构介绍" class="headerlink" title="数据结构介绍"></a>数据结构介绍</h3><p>Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样：</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503141011784.png" alt=""></p>
<p>GEO：地理位置</p>
<p><strong>贴心小建议：命令不要死记，学会查询就好啦</strong></p>
<p>Redis为了方便我们学习，将操作不同数据类型的命令也做了分组，在官网（ <a target="_blank" rel="noopener" href="https://redis.io/commands">https://redis.io/commands</a> ）可以查看到不同的命令。</p>
<p>或者通过Help命令来帮助我们去查看命令：</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503141016038.png" alt=""></p>
<h3 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h3><p>通用指令是部分数据类型的都可以使用的指令，可以通过<code>help @generic</code>查看有哪些通用命令，常见的有：</p>
<ul>
<li><p>KEYS：查看符合模板的所有key</p>
<ul>
<li><p>```sh<br>127.0.0.1:6379&gt; keys *<br>1) “name”<br>2) “age”<br>127.0.0.1:6379&gt;</p>
<h1 id="查询以a开头的key"><a href="#查询以a开头的key" class="headerlink" title="查询以a开头的key"></a>查询以a开头的key</h1><p>127.0.0.1:6379&gt; keys a*<br>1) “age”<br>127.0.0.1:6379&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    **贴心小提示：在生产环境下，不推荐使用keys 命令，因为这个命令在key过多的情况下，效率不高，模糊查询**</span><br><span class="line"></span><br><span class="line">- DEL：删除一个指定的key</span><br><span class="line"></span><br><span class="line">  - ```sh</span><br><span class="line">    127.0.0.1:6379&gt; del name #删除单个</span><br><span class="line">    (integer) 1  #成功删除1个</span><br><span class="line">    </span><br><span class="line">    127.0.0.1:6379&gt; keys *</span><br><span class="line">    1) &quot;age&quot;</span><br><span class="line">    </span><br><span class="line">    127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3 #批量添加数据</span><br><span class="line">    OK</span><br><span class="line">    </span><br><span class="line">    127.0.0.1:6379&gt; keys *</span><br><span class="line">    1) &quot;k3&quot;</span><br><span class="line">    2) &quot;k2&quot;</span><br><span class="line">    3) &quot;k1&quot;</span><br><span class="line">    4) &quot;age&quot;</span><br><span class="line">    </span><br><span class="line">    127.0.0.1:6379&gt; del k1 k2 k3 k4</span><br><span class="line">    (integer) 3   #此处返回的是成功删除的key，由于redis中只有k1,k2,k3 所以只成功删除3个，最终返回</span><br><span class="line">    127.0.0.1:6379&gt;</span><br><span class="line">    </span><br><span class="line">    127.0.0.1:6379&gt; keys * #再查询全部的key</span><br><span class="line">    1) &quot;age&quot;	#只剩下一个了</span><br><span class="line">    127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>EXISTS：判断key是否存在</p>
<ul>
<li><p>```sh<br>127.0.0.1:6379&gt; help EXISTS</p>
<p>  EXISTS key [key …]<br>  summary: Determine if a key exists<br>  since: 1.0.0<br>  group: generic</p>
<p>127.0.0.1:6379&gt; exists age<br>(integer) 1</p>
<p>127.0.0.1:6379&gt; exists name<br>(integer) 0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除（为什么会存在这个命令：因为Redis是在内存中存储的，内存非常宝贵）</span><br><span class="line"></span><br><span class="line">  - ```sh</span><br><span class="line">    127.0.0.1:6379&gt; expire age 10</span><br><span class="line">    (integer) 1</span><br><span class="line">    </span><br><span class="line">    127.0.0.1:6379&gt; ttl age</span><br><span class="line">    (integer) 8</span><br><span class="line">    </span><br><span class="line">    127.0.0.1:6379&gt; ttl age</span><br><span class="line">    (integer) 6</span><br><span class="line">    </span><br><span class="line">    127.0.0.1:6379&gt; ttl age</span><br><span class="line">    (integer) -2</span><br><span class="line">    </span><br><span class="line">    127.0.0.1:6379&gt; ttl age</span><br><span class="line">    (integer) -2  #当这个key过期了，那么此时查询出来就是-2 </span><br><span class="line">    </span><br><span class="line">    127.0.0.1:6379&gt; keys *</span><br><span class="line">    (empty list or set)</span><br><span class="line">    </span><br><span class="line">    127.0.0.1:6379&gt; set age 10 #如果没有设置过期时间</span><br><span class="line">    OK</span><br><span class="line">    </span><br><span class="line">    127.0.0.1:6379&gt; ttl age</span><br><span class="line">    (integer) -1  # ttl的返回值就是-1</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>TTL：查看一个KEY的剩余有效期</p>
</li>
</ul>
<h3 id="String命令"><a href="#String命令" class="headerlink" title="String命令"></a>String命令</h3><p> String类型，也就是字符串类型，是Redis中最简单的存储类型。</p>
<p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p>
<ul>
<li>string：普通字符串</li>
<li>int：整数类型，可以做自增，自减操作</li>
<li>float：浮点类型，可以做自增，自减操作</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>KEY</th>
<th>VALUE</th>
</tr>
</thead>
<tbody>
<tr>
<td>msg</td>
<td>hello world</td>
</tr>
<tr>
<td>num</td>
<td>10</td>
</tr>
<tr>
<td>score</td>
<td>92.5</td>
</tr>
</tbody>
</table>
</div>
<p>String的常见命令有：</p>
<ul>
<li>SET：添加或者修改已经存在的一个String类型的键值对</li>
<li>GET：根据key获取String类型的value</li>
<li>MSET：批量添加多个String类型的键值对</li>
<li>MGET：根据多个key获取多个String类型的value</li>
<li>INCR：让一个整型的key自增1</li>
<li>INCRBY:让一个整型的key自增并指定步长（也可以是负数，就是自减），例如：incrby num 2 让num值自增2</li>
<li>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</li>
<li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行<ul>
<li>其实和<code>set 键 nx</code>效果一样，nx是set的参数</li>
</ul>
</li>
<li>SETEX：添加一个String类型的键值对，并且指定有效期<ul>
<li>其实和<code>set 键 ex 数字（表时间）</code></li>
</ul>
</li>
</ul>
<h3 id="Key的层级结构"><a href="#Key的层级结构" class="headerlink" title="Key的层级结构"></a>Key的层级结构</h3><p><strong>问题：</strong>Redis没有类似MySQL中的Table的概念，我们该如何区分不同类型的key呢？例如，需要存储用户.商品信息到redis，有一个用户id是1，有一个商品id恰好也是1，此时如果使用id作为key，那就会冲突了，该怎么办？</p>
<p><strong>解决方案：</strong>可以通过给key添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范。</p>
<p>Redis的key允许有多个单词形成层级结构，多个单词之间用<code>:</code>隔开，格式如下：<code>项目名:业务名:类型:id</code>。这个格式并非固定，也可以根据自己的需求来删除或添加词条。</p>
<p>例如我们的项目名称叫 heima，有user和product两种不同类型的数据，我们可以这样定义key：</p>
<ul>
<li><p>user相关的key：<strong>heima:user:1</strong></p>
</li>
<li><p>product相关的key：<strong>heima:product:1</strong></p>
</li>
</ul>
<p>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>KEY</strong></th>
<th><strong>VALUE</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>heima:user:1</td>
<td>{“id”:1, “name”: “Jack”, “age”: 21}</td>
</tr>
<tr>
<td>heima:product:1</td>
<td>{“id”:1, “name”: “小米11”, “price”: 4999}</td>
</tr>
</tbody>
</table>
</div>
<p>一旦我们向redis采用这样的方式存储，那么在可视化界面中，redis会以层级结构来进行存储，形成类似于这样的结构，更加方便Redis获取数据。</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503141112678.png" alt=""></p>
<h3 id="Hash命令"><a href="#Hash命令" class="headerlink" title="Hash命令"></a>Hash命令</h3><p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p>
<p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便：</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503141341609.png" alt=""></p>
<p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503141341613.png" alt=""></p>
<p><strong>Hash类型的常见命令</strong></p>
<ul>
<li><p>HSET key field value：添加或者修改hash类型key的field的值</p>
<ul>
<li>```sh<br>127.0.0.1:6379&gt; HSET heima:user:3 name Lucy//大key是 heima:user:3 小key是name，小value是Lucy<br>(integer) 1<br>127.0.0.1:6379&gt; HSET heima:user:3 age 21// 如果操作不存在的数据，则是新增<br>(integer) 1<br>127.0.0.1:6379&gt; HSET heima:user:3 age 17 //如果操作存在的数据，则是修改<br>(integer) 0<br>127.0.0.1:6379&gt; HGET heima:user:3 name<br>“Lucy”<br>127.0.0.1:6379&gt; HGET heima:user:3 age<br>“17”<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- HGET key field：获取一个hash类型key的field的值</span><br><span class="line"></span><br><span class="line">- HMSET：批量添加多个hash类型key的field的值</span><br><span class="line"></span><br><span class="line">- HMGET：批量获取多个hash类型key的field的值</span><br><span class="line"></span><br><span class="line">- HGETALL：获取一个hash类型的key中的所有的field和value</span><br><span class="line"></span><br><span class="line">- HKEYS：获取一个hash类型的key中的所有的field</span><br><span class="line"></span><br><span class="line">- HINCRBY:让一个hash类型key的字段值自增并指定步长</span><br><span class="line"></span><br><span class="line">- HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### List命令</span><br><span class="line"></span><br><span class="line">Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构，既可以支持正向检索和也可以支持反向检索。</span><br><span class="line"></span><br><span class="line">特征也与LinkedList类似：</span><br><span class="line"></span><br><span class="line">* 有序</span><br><span class="line">* 元素可以重复</span><br><span class="line">* 插入和删除快</span><br><span class="line">* 查询速度一般</span><br><span class="line"></span><br><span class="line">常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</span><br><span class="line"></span><br><span class="line">**List的常见命令有：**</span><br><span class="line"></span><br><span class="line">- LPUSH key element ... ：向列表左侧插入一个或多个元素</span><br><span class="line">- LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</span><br><span class="line">- RPUSH key element ... ：向列表右侧插入一个或多个元素</span><br><span class="line">- RPOP key：移除并返回列表右侧的第一个元素</span><br><span class="line">- LRANGE key star end：返回一段角标范围内的所有元素</span><br><span class="line">- BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</span><br><span class="line"></span><br><span class="line">* LPUSH和RPUSH</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">127.0.0.1:6379&gt; LPUSH users 1 2 3</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; RPUSH users 4 5 6</span><br><span class="line">(integer) 6</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li>以上操作完之后是<code>3 2 1 4 5 6</code></li>
<li>LPOP和RPOP</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LPOP users</span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; RPOP users</span><br><span class="line"><span class="string">&quot;6&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>以上操作完之后是<code>2 1 4 5</code></li>
<li>LRANGE</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LRANGE users <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;4&quot;</span></span><br></pre></td></tr></table></figure>
<p>如何用List结构模拟一个栈？</p>
<ul>
<li>入口和出口在同一边</li>
</ul>
<p>如何用List结构模拟一个队列？</p>
<ul>
<li>入口和出口在不同边</li>
</ul>
<p>如何用List结构模拟一个阻塞队列？</p>
<ul>
<li>入口和出口在不同边</li>
<li>出队时采用BLPOP或BRPOP</li>
</ul>
<h3 id="Set命令"><a href="#Set命令" class="headerlink" title="Set命令"></a>Set命令</h3><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p>
<ul>
<li>无序</li>
<li>元素不可重复</li>
<li>查找快</li>
<li>支持交集、并集、差集等功能</li>
</ul>
<p><strong>Set类型的常见命令</strong></p>
<ul>
<li>SADD key member … ：向set中添加一个或多个元素</li>
<li>SREM key member … : 移除set中的指定元素</li>
<li>SCARD key： 返回set中元素的个数</li>
<li>SISMEMBER key member：判断一个元素是否存在于set中</li>
<li>SMEMBERS：获取set中的所有元素</li>
<li>SINTER key1 key2 … ：求key1与key2的交集</li>
<li>SDIFF key1 key2 … ：求key1与key2的差集</li>
<li>SUNION key1 key2 ..：求key1和key2的并集</li>
</ul>
<h3 id="SortedSet命令"><a href="#SortedSet命令" class="headerlink" title="SortedSet命令"></a>SortedSet命令</h3><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</p>
<p>SortedSet具备下列特性：</p>
<ul>
<li>可排序</li>
<li>元素不重复</li>
<li>查询速度快</li>
</ul>
<p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p>
<p>SortedSet的常见命令有：</p>
<ul>
<li>ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值</li>
<li>ZREM key member：删除sorted set中的一个指定元素</li>
<li>ZSCORE key member : 获取sorted set中的指定元素的score值</li>
<li>ZRANK key member：获取sorted set 中的指定元素的排名</li>
<li>ZCARD key：获取sorted set中的元素个数</li>
<li>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</li>
<li>ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值</li>
<li>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素</li>
<li>ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素</li>
<li>ZDIFF.ZINTER.ZUNION：求差集.交集.并集</li>
</ul>
<p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</p>
<ul>
<li><strong>升序</strong>获取sorted set 中的指定元素的排名：ZRANK key member</li>
<li><strong>降序</strong>获取sorted set 中的指定元素的排名：ZREVRANK key memeber</li>
</ul>
<h2 id="Redis的Java客户端-Jedis"><a href="#Redis的Java客户端-Jedis" class="headerlink" title="Redis的Java客户端-Jedis"></a>Redis的Java客户端-Jedis</h2><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><p>1.创建工程</p>
<p>2.引入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--jedis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>/version&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--单元测试--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>3.建立连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.建立连接</span></span><br><span class="line">    <span class="comment">// jedis = new Jedis(&quot;192.168.150.101&quot;, 6379);</span></span><br><span class="line">    jedis = JedisConnectionFactory.getJedis();</span><br><span class="line">    <span class="comment">// 2.设置密码</span></span><br><span class="line">    jedis.auth(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.选择库</span></span><br><span class="line">    jedis.select(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 存入数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;虎哥&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">    <span class="comment">// 获取数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 插入hash数据</span></span><br><span class="line">    jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取</span></span><br><span class="line">    Map&lt;String, String&gt; map = jedis.hgetAll(<span class="string">&quot;user:1&quot;</span>);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5.释放资源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Jedis连接池"><a href="#Jedis连接池" class="headerlink" title="Jedis连接池"></a>Jedis连接池</h3><p>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式</p>
<p>有关池化思想，并不仅仅是这里会使用，很多地方都有，比如说我们的数据库连接池，比如我们tomcat中的线程池，这些都是池化思想的体现</p>
<p><strong>创建Jedis连接池</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectionFacotry</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">static</span> &#123;</span><br><span class="line">         <span class="comment">//配置连接池</span></span><br><span class="line">         <span class="type">JedisPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">         poolConfig.setMaxTotal(<span class="number">8</span>);</span><br><span class="line">         poolConfig.setMaxIdle(<span class="number">8</span>);</span><br><span class="line">         poolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line">         poolConfig.setMaxWait(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">         <span class="comment">//创建连接池对象</span></span><br><span class="line">         jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(poolConfig,</span><br><span class="line">                 <span class="string">&quot;192.168.57.130&quot;</span>,<span class="number">6379</span>,<span class="number">1000</span>,<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li><p>JedisConnectionFacotry：工厂设计模式是实际开发中非常常用的一种设计模式，我们可以使用工厂，去降低代的耦合，比如Spring中的Bean的创建，就用到了工厂设计模式</p>
</li>
<li><p>静态代码块：随着类的加载而加载，确保只能执行一次，我们在加载当前工厂类的时候，就可以执行static的操作完成对 连接池的初始化</p>
</li>
<li><p>最后提供返回连接池中连接的方法.</p>
</li>
</ul>
<p><strong>改造原始代码</strong></p>
<p><strong>代码说明:</strong></p>
<p>1.在我们完成了使用工厂设计模式来完成代码的编写之后，我们在获得连接时，就可以通过工厂来获得，而不用直接去new对象，降低耦合，并且使用的还是连接池对象。</p>
<p>2.当我们使用了连接池后，当我们关闭连接其实并不是关闭，而是将Jedis还回连接池的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@BeforeEach</span></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="comment">//建立连接</span></span><br><span class="line">     <span class="comment">/*jedis = new Jedis(&quot;127.0.0.1&quot;,6379);*/</span></span><br><span class="line">     jedis = JedisConnectionFacotry.getJedis();</span><br><span class="line">      <span class="comment">//选择库</span></span><br><span class="line">     jedis.select(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">         jedis.close();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Redis的Java客户端-SpringDataRedis"><a href="#Redis的Java客户端-SpringDataRedis" class="headerlink" title="Redis的Java客户端-SpringDataRedis"></a>Redis的Java客户端-SpringDataRedis</h2><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p>
<ul>
<li>提供了对不同Redis客户端的整合（Lettuce和Jedis）</li>
<li>提供了RedisTemplate统一API来操作Redis</li>
<li>支持Redis的发布订阅模型</li>
<li>支持Redis哨兵和Redis集群</li>
<li>支持基于Lettuce的响应式编程</li>
<li>支持基于JDK.JSON.字符串.Spring对象的数据序列化及反序列化</li>
<li>支持基于Redis的JDKCollection实现</li>
</ul>
<p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503141603696.png" alt=""></p>
<h4 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h4><p>1.导入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--redis依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--common-pool--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2.配置文件</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.57</span><span class="number">.130</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123321</span></span><br><span class="line">      <span class="attr">lettuce:</span></span><br><span class="line">        <span class="attr">pool:</span></span><br><span class="line">          <span class="attr">max-active:</span> <span class="number">8</span>  <span class="comment">#最大连接</span></span><br><span class="line">          <span class="attr">max-idle:</span> <span class="number">8</span>  <span class="comment">#最大空闲连接</span></span><br><span class="line">          <span class="attr">min-idle:</span> <span class="number">0</span>  <span class="comment">#最小空闲连接</span></span><br><span class="line">          <span class="attr">max-wait:</span> <span class="string">1000ms</span>  <span class="comment">#最小空闲连接</span></span><br></pre></td></tr></table></figure>
<p>3.测试代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisDemoApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 写入一条String数据</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;虎哥&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取string数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数据序列化器"><a href="#数据序列化器" class="headerlink" title="数据序列化器"></a>数据序列化器</h4><p>RedisTemplate可以接收任意Object作为值写入Redis，只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果是这样的：</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503141813595.png" alt=""></p>
<p>缺点：</p>
<ul>
<li>可读性差</li>
<li>内存占用较大</li>
</ul>
<p>我们可以自定义RedisTemplate的序列化方式，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 创建JSON序列化工具</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jsonRedisSerializer</span> <span class="operator">=</span> </span><br><span class="line">            							<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// 设置Key的序列化</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// 设置Value的序列化</span></span><br><span class="line">        template.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里采用了JSON序列化来代替默认的JDK序列化方式。最终结果如图：</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503141815710.png" alt=""></p>
<p>整体可读性有了很大提升，并且能将Java对象自动的序列化为JSON字符串，并且查询时能自动把JSON反序列化为Java对象。不过，其中记录了序列化时对应的class名称，目的是为了查询时实现自动反序列化。这会带来额外的内存开销。</p>
<h4 id="StringRedisTemplate"><a href="#StringRedisTemplate" class="headerlink" title="StringRedisTemplate"></a>StringRedisTemplate</h4><p>尽管JSON的序列化方式可以满足我们的需求，但依然存在一些问题，如上图。</p>
<p>为了在反序列化时知道对象的类型，JSON序列化器会将类的class类型写入json结果中，存入Redis，会带来额外的内存开销。</p>
<p>为了减少内存的消耗，我们可以采用手动序列化的方式，换句话说，就是不借助默认的序列化器，而是我们自己来控制序列化的动作，同时，我们只采用String的序列化器，这样，在存储value时，我们就不需要在内存中就不用多存储数据，从而节约我们的内存空间。</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503141818150.png" alt=""></p>
<p>这种用法比较普遍，因此SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式。</p>
<p>省去了我们自定义RedisTemplate的序列化方式的步骤，而是直接使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisStringTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 写入一条String数据</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;verify:phone:13600527634&quot;</span>, <span class="string">&quot;124143&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取string数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;虎哥&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        <span class="comment">// 手动序列化</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line">        <span class="comment">// 写入数据</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:200&quot;</span>, json);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonUser</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:200&quot;</span>);</span><br><span class="line">        <span class="comment">// 手动反序列化</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> mapper.readValue(jsonUser, User.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;user1 = &quot;</span> + user1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503141826954.png" alt=""></p>
<p><strong>总结：</strong></p>
<p>RedisTemplate的两种序列化实践方案：</p>
<ul>
<li><p>方案一：</p>
<ul>
<li>自定义RedisTemplate</li>
<li>修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer</li>
</ul>
</li>
<li><p>方案二：</p>
<ul>
<li>使用StringRedisTemplate</li>
<li>写入Redis时，手动把对象序列化为JSON</li>
<li>读取Redis时，手动把读取到的JSON反序列化为对象</li>
</ul>
</li>
</ul>
<h4 id="Hash结构操作"><a href="#Hash结构操作" class="headerlink" title="Hash结构操作"></a>Hash结构操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisStringTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForHash().put(<span class="string">&quot;user:400&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;虎哥&quot;</span>);</span><br><span class="line">        stringRedisTemplate.opsForHash().put(<span class="string">&quot;user:400&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Map&lt;Object, Object&gt; entries = stringRedisTemplate.opsForHash().entries(<span class="string">&quot;user:400&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;entries = &quot;</span> + entries);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="实战篇"><a href="#实战篇" class="headerlink" title="实战篇"></a>实战篇</h1><h2 id="短信登录"><a href="#短信登录" class="headerlink" title="短信登录"></a>短信登录</h2><p>流程：</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503191656667.png" alt=""></p>
<p>集群的session共享问题：</p>
<p>session共享问题：多台Tomcat并不共享session存储空间，当请求切换到不同tomcat服务时导致数据丢失的问题。</p>
<p>session的替代方案应该满足：</p>
<ul>
<li>数据共享</li>
<li>内存存储</li>
<li><p>key、value结构</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503211549934.png" alt=""></p>
</li>
</ul>
<p>改进后的流程：</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503211557167.png" alt=""></p>
<p>保存用户到Redis中不用手机号作为Redis的key是因为：要返回给前端并放在authorization中，为了以后登录时进行验证，如果用手机号的话容易泄漏。</p>
<p>登录拦截器的优化：</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503211644076.png" alt=""></p>
<p>原来的登录拦截器存在的问题：不拦截一些不需要登录的api，比如首页、获取验证码等，如果将刷新token有效期的代码放在这里面，就会导致用户在访问首页或者其他不被拦截的api时token不会被刷新。</p>
<p>改进：</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503211646385.png" alt=""></p>
<h2 id="商户查询"><a href="#商户查询" class="headerlink" title="商户查询"></a>商户查询</h2><h3 id="什么是缓存"><a href="#什么是缓存" class="headerlink" title="什么是缓存"></a>什么是缓存</h3><p>缓存就是数据交换的缓存区（称作Cache），是贮存数据的临时地方，一般读写性能较高。</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503211938521.png" alt=""></p>
<p>缓存的作用：</p>
<ul>
<li>降低后端负载</li>
<li>提高读写效率，降低响应时间</li>
</ul>
<p>缓存的成本：</p>
<ul>
<li>数据一致性成本</li>
<li>代码维护成本</li>
<li>运维成本</li>
</ul>
<h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>内存淘汰</th>
<th>超时剔除</th>
<th>主动更新</th>
</tr>
</thead>
<tbody>
<tr>
<td>说明</td>
<td>不用自己维护，利用Redis的内存淘汰机制，当内存不足时自动淘汰部分数据。下次查询时更新缓存。</td>
<td>给缓存数据添加TTL时间，到期后自动删除缓存。下次查询时更新缓存。</td>
<td>编写业务逻辑，在修改数据库的同时，更新缓存。</td>
</tr>
<tr>
<td>一致性</td>
<td>差</td>
<td>一般</td>
<td>好</td>
</tr>
<tr>
<td>维护成本</td>
<td>无</td>
<td>低</td>
<td>高</td>
</tr>
</tbody>
</table>
</div>
<p>业务场景：</p>
<ul>
<li>低一致性需求：使用内存淘汰机制。例如店铺类型的查询缓存。</li>
<li>高一致性需求：主动更新，并以超时剔除作为兜底方案。例如店铺详情查询的缓存。</li>
</ul>
<h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><ul>
<li>Cache Aside Pattern：由缓存的调用者，在更新数据库的同时更新缓存。（主要使用）</li>
<li>Read/Write Through Pattern：缓存与数据库整合为一个服务，由服务来维护一致性。调用者调用该服务，无需关心缓存一致性问题。</li>
<li>Write Behind Caching Pattern：调用者只操作缓存，由其他线程异步的将缓存数据持久化到数据库，保证最终一致。</li>
</ul>
<p>Cache Aside Pattern存在的三个问题</p>
<ul>
<li>删除缓存还是更新缓存？<ul>
<li>更新缓存：每次更新数据库都要更新缓存，无效写操作较多</li>
<li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存</li>
</ul>
</li>
<li>如何保证缓存与数据库的操作的同时成功或失败？<ul>
<li>单体系统，将缓存与数据库操作放在一个事务</li>
<li>分布式系统，利用TCC等分布事务方案</li>
</ul>
</li>
<li>先操作缓存还是先操作数据库？<ul>
<li>先删除缓存，再操作数据库</li>
<li>先操作数据库，再删除缓存</li>
</ul>
</li>
</ul>
<h5 id="先删除缓存，再操作数据库"><a href="#先删除缓存，再操作数据库" class="headerlink" title="先删除缓存，再操作数据库"></a>先删除缓存，再操作数据库</h5><p>正常情况：</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503261519943.png" alt=""></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>步骤</th>
<th>缓存</th>
<th>数据库</th>
</tr>
</thead>
<tbody>
<tr>
<td>初始</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>10</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>20</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>20</td>
</tr>
<tr>
<td>4</td>
<td>20</td>
<td>20</td>
</tr>
</tbody>
</table>
</div>
<p>异常情况：</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503261520155.png" alt=""></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>步骤</th>
<th>缓存</th>
<th>数据库</th>
</tr>
</thead>
<tbody>
<tr>
<td>初始</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>10</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>10</td>
</tr>
<tr>
<td>3</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td>4</td>
<td>10</td>
<td>20</td>
</tr>
</tbody>
</table>
</div>
<p>因为更新数据库的操作一般是很慢的，而删除缓存的操作是很快的，很可能线程1删除缓存之后，先让线程2执行。</p>
<p>这种情况发生的可能性比较高。</p>
<h5 id="先操作数据库，再删除缓存"><a href="#先操作数据库，再删除缓存" class="headerlink" title="先操作数据库，再删除缓存"></a>先操作数据库，再删除缓存</h5><p>正常情况：</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503261524686.png" alt=""></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>步骤</th>
<th>缓存</th>
<th>数据库</th>
</tr>
</thead>
<tbody>
<tr>
<td>初始</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td>1</td>
<td>10</td>
<td>20</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>20</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>20</td>
</tr>
<tr>
<td>4</td>
<td>20</td>
<td>20</td>
</tr>
</tbody>
</table>
</div>
<p>异常情况（假设线程1查询时，缓存恰好失效了）：</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503261531031.png" alt=""></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>步骤</th>
<th>缓存</th>
<th>数据库</th>
</tr>
</thead>
<tbody>
<tr>
<td>初始</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>10</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>20</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>20</td>
</tr>
<tr>
<td>4</td>
<td>10</td>
<td>20</td>
</tr>
</tbody>
</table>
</div>
<p>情况发生的条件：</p>
<ul>
<li>两个线程在并行执行</li>
<li>线程1查询时，缓存恰好失效</li>
<li>线程1查询后，要写入缓存之间（之间微秒级）突然来了一个线程（这里是线程2）要更新数据库，删缓存。</li>
</ul>
<p>综合分析，可能性比较低。</p>
<h4 id="缓存更新策略的最佳实践"><a href="#缓存更新策略的最佳实践" class="headerlink" title="缓存更新策略的最佳实践"></a>缓存更新策略的最佳实践</h4><ul>
<li>删除缓存还是更新缓存？删除缓存</li>
<li>方案2（即先操作数据库，再删除缓存）发生异常情况的可能性较低。</li>
</ul>
<p>1.低一致性需求：使用Redis自带的内存淘汰机制</p>
<p>2.高一致性需求：主动更新，并以超时剔除作为兜底方案</p>
<ul>
<li>读操作：<ul>
<li>缓存命中则直接返回</li>
<li>缓存未命中则查询数据库，并写入缓存，设定超时时间</li>
</ul>
</li>
<li>写操作：<ul>
<li>先写数据库，然后再删除缓存</li>
<li>要确保数据库与缓存操作的原子性</li>
</ul>
</li>
</ul>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透是指客户端请求的数据在缓存中和数据库都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p>
<p>危害：</p>
<p>常见的解决方案有两种：</p>
<ul>
<li>缓存空对象<ul>
<li>优点：实现简单，维护方便</li>
<li>缺点：<ul>
<li>额外的内存消耗（比如请求一堆不存在的id，就会导致缓存中存储大量不存在id的null对象。<strong>解决办法</strong>：设置较短的TTL）</li>
<li>可能造成短期的不一致（比如请求一个不存在的id，然后缓存中存储了它的null对象，然后插入了这个id的商铺，再查询这个id，查到的是缓存中的null对象。<strong>解决办法</strong>：插入这条数据的时候，主动在缓存中覆盖数据）</li>
</ul>
</li>
</ul>
</li>
<li>布隆过滤<ul>
<li>原理：可以简单理解成一个byte数组，把数据库中的数据基于某一种hash算法计算出hash值，然后将这些hash值转换成二进制保存到布隆过滤器里。判断数据是否存在是判断对应的位置是0还是1。这种存在判断是概率上的统计，不是百分百的准确。<strong>重点</strong>：当布隆过滤器说不存在时，百分百不存在；当布隆过滤器说存在时，不一定存在。</li>
<li>优点：内存占用较少，没有多余key</li>
<li>缺点：<ul>
<li>实现复杂</li>
<li>存在误判可能（当布隆过滤器说不存在时，百分百不存在；当布隆过滤器说存在时，不一定存在。）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503261612599.png" alt=""></p>
<h4 id="解决商铺查询的缓存穿透问题"><a href="#解决商铺查询的缓存穿透问题" class="headerlink" title="解决商铺查询的缓存穿透问题"></a>解决商铺查询的缓存穿透问题</h4><p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503261624010.png" alt=""></p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>缓存穿透产生的原因是什么？</p>
<p>用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力</p>
<p>缓存穿透的解决方案有哪些？</p>
<ul>
<li>缓存null值（被动）</li>
<li>布隆过滤（被动）</li>
<li>增强id的复杂度，避免被猜测id规律</li>
<li>做好数据的基础格式校验（比如0这种id）</li>
<li>加强用户权限校验（要登录才能访问，或者访问频率限制）</li>
<li>做好热点参数的限流</li>
</ul>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩是指在<strong>同一时段大量的缓存key同时失效</strong>或者<strong>Redis服务宕机</strong>，导致大量请求到达数据库，带来巨大压力。</p>
<p>解决方案：</p>
<ul>
<li>给不同的Key的TTL添加随机值（针对同一时段大量的缓存key同时失效）</li>
<li>利用Redis集群提高服务的可用性</li>
<li>给缓存业务添加降级限流策略</li>
<li>给业务添加多级缓存</li>
</ul>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿问题也叫热点Key问题，就是一个被<strong>高并发访问</strong>并且<strong>缓存重建业务较复杂</strong>的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503261653045.png" alt=""></p>
<p>图中查询数据库，重建缓存的线段比较长，表示所需时间比较长。</p>
<p>常见的解决方案有两种：</p>
<ul>
<li>互斥锁（只有一个线程能获取锁，其他线程都需要等待，所以性能上会比较差）<ul>
<li><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503261709782.png" alt=""></li>
</ul>
</li>
<li>逻辑过期（向redis存储数据时，不设置TTL，逻辑过期不是真正的过期，它要求我们在存储数据到redis的时候，额外的要添加一个过期时间的字段，这个key本身是不用去设置ttl的，所以它的过期时间不是由redis控制的，而是由我们程序员自己去判断它是否过期）<ul>
<li><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503261710253.png" alt=""></li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>解决方案</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>互斥锁</td>
<td>1.没有额外的内存消耗<br />2.保证一致性<br />3.实现简单</td>
<td>1.线程需要等待，性能受影响<br />2.可能有死锁风险</td>
</tr>
<tr>
<td>逻辑过期</td>
<td>线程无需等待，性能较好</td>
<td>1.不保证一致性<br />2.有额外内存消耗<br />3.实现复杂</td>
</tr>
</tbody>
</table>
</div>
<h4 id="基于互斥锁方式解决缓存击穿问题"><a href="#基于互斥锁方式解决缓存击穿问题" class="headerlink" title="基于互斥锁方式解决缓存击穿问题"></a>基于互斥锁方式解决缓存击穿问题</h4><p>利用Redis中string的setnx命令来实现：setnx，对key进行赋值（当且仅当key不存在时赋值）</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503271034998.png" alt=""></p>
<h4 id="基于逻辑过期方式解决缓存击穿问题"><a href="#基于逻辑过期方式解决缓存击穿问题" class="headerlink" title="基于逻辑过期方式解决缓存击穿问题"></a>基于逻辑过期方式解决缓存击穿问题</h4><p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202503281405636.png" alt=""></p>
<h4 id="注意事项（important）"><a href="#注意事项（important）" class="headerlink" title="注意事项（important）"></a>注意事项（important）</h4><blockquote>
<p>在查看点评时，会报店铺不存在，是因为之前解决缓存击穿问题使用的时基于逻辑过期时间的方式，当时给缓存中的店铺数据添加逻辑过期时间的时候只添加了一个店铺，没有将所有店铺都添加逻辑过期时间，同时也不是所有店铺数据都被添加到了缓存中去，当点击相关点评时，涉及到为添加到缓存中的店铺，由缓存击穿的流程，会直接返回null，从而返回Result.fail(“店铺不存在！”);</p>
</blockquote>
<p>缓存为命中直接返回空，因为已经提前将商铺的数据添加到redis中，设置了逻辑过期时间，所以如果在redis都查不到，那么数据库也查不到。</p>
<p>如果自己删除了redis中的商铺数据，应该使用项目中的单元测试进行添加商铺数据到Redis中，否则后续查询点评的时候，会显示店铺不存在。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	批量添加商铺缓存数据和设置逻辑过期时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSaveShop</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1L</span>; id &lt;= <span class="number">14L</span>; id++) &#123;</span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> shopService.getById(id);</span><br><span class="line">        cacheClient.setWithLogicalExpire(CACHE_SHOP_KEY + id, shop, <span class="number">10L</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他文件中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithLogicalExpire</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">    <span class="comment">// 设置逻辑过期</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">    redisData.setData(value);</span><br><span class="line">    redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));</span><br><span class="line">    <span class="comment">// 写入Redis</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优惠券秒杀"><a href="#优惠券秒杀" class="headerlink" title="优惠券秒杀"></a>优惠券秒杀</h2><h3 id="全局ID生成器"><a href="#全局ID生成器" class="headerlink" title="全局ID生成器"></a>全局ID生成器</h3><p>当用户抢购时，就会生成订单保存到tb_voucher_order这张表中，而订单表如果使用数据库自增ID就存在一些问题：</p>
<ul>
<li>id的规律性太明显（用户可以间接知晓每日销量）</li>
<li>受单表数据量的限制（订单特别多，不能用单表存储，用多表存储，每个表id自增会重复）</li>
</ul>
<p>全局ID生成器，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：</p>
<ul>
<li>唯一性</li>
<li>高可用</li>
<li>高性能</li>
<li>递增性</li>
<li>安全性</li>
</ul>
<p>为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其他信息：</p>
<p>使用数值类型存储（Long类型，8Byte）</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504021413746.png" alt=""></p>
<p>ID的组成部分：</p>
<ul>
<li>符号位：1bit，永远为0</li>
<li>时间戳：31bit，以秒为单位，可以使用69年</li>
<li>序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID</li>
</ul>
<p>全局唯一ID生成策略：</p>
<ul>
<li>UUID（生成的是十六进制的数值，返回的是字符串结构，没有自增）</li>
<li>Redis自增</li>
<li>snowflake算法（雪花算法）</li>
<li>数据库自增（用一张表专门做自增）</li>
</ul>
<p>Redis自增ID策略：</p>
<ul>
<li>每天一个key，方便统计订单量</li>
<li>ID构造是时间戳+计数器</li>
</ul>
<h3 id="实现秒杀下单"><a href="#实现秒杀下单" class="headerlink" title="实现秒杀下单"></a>实现秒杀下单</h3><p>实现优惠券秒杀下单功能</p>
<p>下单需要判断两点：</p>
<ul>
<li>秒杀是否开始或结束，如果尚未开始或已经结束则无法下单</li>
<li>库存是否充足，不足则无法下单</li>
</ul>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504021547012.png" alt=""></p>
<h3 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a>超卖问题</h3><p>原库存是1</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504021631709.png" alt=""></p>
<p>超卖问题是点选的多线程安全问题，针对这一问题的常见解决方案就是加锁。</p>
<h4 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h4><p><strong>悲观锁：</strong></p>
<p>认为线程安全问题一定会发生，因此在操作数据之前先获取锁，确保线程串行执行。</p>
<ul>
<li>例如Synchronized、Lock都属于悲观锁</li>
</ul>
<p><strong>乐观锁：</strong></p>
<p>认为线程安全问题不一定会发生，因此不加锁，只是在更新数据时去判断有没有其他线程对数据做了修改。</p>
<ul>
<li>如果没有修改则认为是安全的，自己才更新数据。</li>
<li>如果已经被其他线程修改说明发生了安全问题，此时可以重试或异常。</li>
</ul>
<h5 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h5><p>乐观锁的关键是判断之前查询得到的数据是否有被修改过，常见的方式有两种：</p>
<p><strong>1.版本号法：</strong></p>
<p>原理：查询的版本号和修改时的版本号有没有变，每次修改版本号+1。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>步骤</th>
<th>id</th>
<th>stock</th>
<th>version</th>
</tr>
</thead>
<tbody>
<tr>
<td>初始</td>
<td>10</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>线程1第一步</td>
<td>10</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>线程2第一步</td>
<td>10</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>线程1第二步</td>
<td>10</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>线程2第二步</td>
<td>10</td>
<td>0</td>
<td>2</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504021644630.png" alt=""></p>
<p>改进：每次版本号变化的时候库存也会变化，所以可以将库存作为版本号，即每次修改的时候看与查询的时候库存有没有变，没变则修改，<strong>也就是下面的CAS法。</strong></p>
<p><strong>2.CAS法</strong> （compare and set）</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504021656316.png" alt=""></p>
<h5 id="乐观锁解决超卖问题"><a href="#乐观锁解决超卖问题" class="headerlink" title="乐观锁解决超卖问题"></a>乐观锁解决超卖问题</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5.扣减库存--修改前</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">    .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)  <span class="comment">// set stock = stock - 1</span></span><br><span class="line">    .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId) <span class="comment">// where id = ?</span></span><br><span class="line">    .update();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.扣减库存--修改后</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">    .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)  <span class="comment">// set stock = stock - 1</span></span><br><span class="line">    .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).eq(<span class="string">&quot;stock&quot;</span>, voucher.getStock())  <span class="comment">// where id = ? and stock = ?</span></span><br><span class="line">    .update();</span><br></pre></td></tr></table></figure>
<p>使用上面的CAS法改写代码，会发现失败率大大增加。</p>
<p><strong>原因是</strong>：假设库存100，有100个线程同步执行，全部查询得到的库存都是100，最先执行的那个线程执行后库存数为99，其他99个线程查询到库存为99（与一开始查询到的库存100不同，不执行）</p>
<p><strong>这里是有并发，但是没有业务安全问题，因为只要大于0就行执行。</strong></p>
<p>乐观锁问题：成功率太低。</p>
<p><strong>改进：</strong></p>
<p>只要库存大于0就能执行。</p>
<h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><p>悲观锁：添加同步锁，让线程串行执行</p>
<ul>
<li>优点：简单粗暴</li>
<li>性能一般</li>
</ul>
<p>乐观锁：不加锁，在更新时判断是否有其他线程在修改</p>
<ul>
<li>优点：性能好</li>
<li>缺点：存在成功率低的问题</li>
</ul>
<h3 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h3><p>需求：修改秒杀业务，要求同一个优惠券，一个用户只能下一单</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504021844135.png" alt=""></p>
<h4 id="并发安全问题"><a href="#并发安全问题" class="headerlink" title="并发安全问题"></a>并发安全问题</h4><p>主要是集群中出现的。</p>
<p>假设图中的灰框表示一个单体</p>
<p>每个jvm中都有自己的锁，两个不同的锁监视器，当前jvm的锁监视器只在当前jvm中有效，所以不同单体的线程各自能获取各自的锁。</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504021934584.png" alt=""></p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504041630451.png" alt=""></p>
<p>分布式锁：满足分布式系统或集群模式下<strong>多进程可见</strong>并且<strong>互斥</strong>的锁。</p>
<p>分布式锁的核心是实现多进程之间互斥，而满足这一点的方式有很多，常见的有三种：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>MySQL</th>
<th>Redis</th>
<th>Zookeeper</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>互斥</strong></td>
<td>利用MySQL本身的互斥锁机制</td>
<td>利用setnx这样的互斥命令</td>
<td>利用节点的唯一性和有序性实现互斥</td>
</tr>
<tr>
<td><strong>高可用</strong></td>
<td>好</td>
<td>好</td>
<td>好</td>
</tr>
<tr>
<td><strong>高性能</strong></td>
<td>一般</td>
<td>好</td>
<td>一般</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>断开连接，自动释放锁</td>
<td>利用锁超时时间，到期释放</td>
<td>临时节点，断开连接自动释放</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>zookeeper创建节点都是唯一的并且id单调递增。</p>
<p>节点的有序性：每创建一个节点，节点的id都是递增的。现在假设很多线程在zookeeper里创建节点，这样id是单调递增的，我们可以约定id最小的那个获取锁成功，这样就实现了互斥。</p>
<p>释放锁：删除该节点即可，这样就不是最小的了。</p>
</blockquote>
<h3 id="基于Redis的分布式锁"><a href="#基于Redis的分布式锁" class="headerlink" title="基于Redis的分布式锁"></a>基于Redis的分布式锁</h3><p>实现分布式锁需要实现两个基本方法：</p>
<ul>
<li><p>获取锁</p>
<ul>
<li><p>互斥：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加锁，利用setnx的互斥性质，lock是key，thread1是value，nx是互斥，ex是设置超时时间，set + nx = setnx</span></span><br><span class="line">SET lock thread1 NX EX 10</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>释放锁</p>
<ul>
<li><p>手动释放：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 释放锁，删除即可，lock是key</span></span><br><span class="line">DEL lock</span><br></pre></td></tr></table></figure>
</li>
<li><p>超时释放：获取锁时添加一个超时时间</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 释放锁，删除即可</span></span><br><span class="line">DEL lock</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504041716939.png" alt=""></p>
<h3 id="Redis分布式误删问题"><a href="#Redis分布式误删问题" class="headerlink" title="Redis分布式误删问题"></a>Redis分布式误删问题</h3><p><strong>极端情况：</strong></p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504051418477.png" alt=""></p>
<p>线程1获取了锁，但是在获取锁后业务发生了阻塞，阻塞时间甚至比锁的超时时间还久（设置锁的时候，设置了超时时间expire ex），这个时候锁提前释放，但是线程1还没执行完。假设这个时候线程2获取了锁，在线程2执行的过程中，线程1业务执行完了，会执行释放锁，也就将线程2的锁释放了。以此类推，当线程3获取了释放的锁，线程2也会释放锁。</p>
<p><strong>解决方案</strong>：</p>
<p>释放锁的时候查看锁的标识和当前标识是否一致（之前获取锁存了线程id）。</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504051420793.png" alt=""></p>
<p>业务流程图变化：</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504051420405.png" alt=""></p>
<p><strong>需求：</strong>修改之前的分布式锁实现，满足：</p>
<p>1.在获取锁时存入线程提示（可以用UUID表示，不用线程ID的原因：jvm每创建一个线程，ID都会递增。如果是在集群的模式下，有多个jvm，所以线程的id很可能冲突）</p>
<p>2.在释放锁时先获取锁中的线程标示，判断是否与当前线程标示一致</p>
<ul>
<li>如果一致则释放锁</li>
<li>如果不一致则不释放锁</li>
</ul>
<h3 id="分布式锁的原子性问题"><a href="#分布式锁的原子性问题" class="headerlink" title="分布式锁的原子性问题"></a>分布式锁的原子性问题</h3><p>接着上面的思路，假设一种极端情况，当线程1获取锁后执行业务后，判断当前标示和锁中标示一致后，开始释放锁，但是释放锁这个动作被阻塞了（这是很可能存在的，因为jvm的垃圾回收机制，当jvm去做full GC的时候，会阻塞所有的代码。）当释放锁这个被阻塞的时间足够长，超过锁的超时时间时，会释放锁，其他线程也就能获取锁了，但线程1释放锁的动作阻塞结束，它也就会执行释放锁的动作，也就把线程2的锁释放了。（在之前的代码中，key是一样的，value是uuid+线程id）</p>
<p>以下是之前的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> <span class="keyword">implements</span> <span class="title class_">ILock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>) + <span class="string">&quot;-&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleRedisLock</span><span class="params">(String name, StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取线程表示</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">        <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">// 有自动拆箱的动作，万一是空的会出错，所以要用以下语句</span></span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取线程标示</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">        <span class="comment">// 获取锁中的标示</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line">        <span class="comment">// 判断标示是否一致</span></span><br><span class="line">        <span class="keyword">if</span>(threadId.equals(id)) &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504051452811.png" alt=""></p>
<p>解决方案：</p>
<p>将判断标示的动作和释放锁的动作整合成一个原子动作。</p>
<p>redis中的事务无法看到中间结果，所以我们用Lua脚本。</p>
<p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令（Redis时在执行他们时，会一次性全部执行），确保多条命令执行时的原子性。</p>
<p>介绍一下lua中Redis提供的调用函数，语法如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 执行set name jack</span></span><br><span class="line">redis.call(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 例如，我们要先执行set name Rose，再执行get name，则脚本如下：</span></span><br><span class="line"><span class="comment">-- 先执行 set name jack</span></span><br><span class="line">redis.call(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;jaclk&#x27;</span>)</span><br><span class="line"><span class="comment">-- 再执行get name</span></span><br><span class="line"><span class="keyword">local</span> name = redis.call(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="comment">-- 返回</span></span><br><span class="line"><span class="keyword">return</span> name</span><br></pre></td></tr></table></figure>
<p>写好脚本后，需要用Redis命令来调用脚本，常见命令如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">help</span> @scripting</span><br><span class="line"></span><br><span class="line">  EVAL script numkeys key [key ...] arg [arg ...]</span><br><span class="line">  summary: Execute a Lua script server side</span><br><span class="line">  since: 2.6.0</span><br></pre></td></tr></table></figure>
<p>例如，我们要执行<code>redis.call(&#39;set&#39;, &#39;name&#39;, &#39;jack&#39;)</code>这个脚本，语法如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用脚本 0代表脚本需要的key类型的参数个数</span></span><br><span class="line">EVAL <span class="string">&quot;return redis.call(&#x27;set&#x27;, &#x27;name&#x27;, &#x27;jack&#x27;)&quot;</span> 0</span><br></pre></td></tr></table></figure>
<p>如果脚本中的key，value不想写死，可以作为参数传递。key类型参数会放入KEYS数组，其他参数会放入ARGV数组，在脚本中可以从KEYS和ARGV数组获取这些参数：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用脚本</span></span><br><span class="line">EVAL <span class="string">&quot;return redis.call(&#x27;set&#x27;, KEYS[1], ARGV[1])&quot;</span> 1 name Rose</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：lua语言中数组下标是从1开始的，不是0</p>
</blockquote>
<p>解决：</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504051521661.png" alt=""></p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>基于Redis的分布式锁实现思路：</p>
<ul>
<li>利用set nx ex获取锁，并设置过期时间，保存线程标示</li>
<li>释放锁时先判断线程标示是否与自己一致，一致则删除锁</li>
</ul>
<p>特性：</p>
<ul>
<li>利用set nx满足互斥性</li>
<li>利用set ex保证故障时锁依然能释放，避免死锁，提高安全性</li>
<li>利用Redis集群保证高可用和高并发特性</li>
</ul>
<h3 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h3><h4 id="基于Redis的分布式锁优化"><a href="#基于Redis的分布式锁优化" class="headerlink" title="基于Redis的分布式锁优化"></a>基于Redis的分布式锁优化</h4><p>基于setnx实现的分布式锁存在下面的问题：</p>
<ul>
<li>不可重入：同一个线程无法多次获取同一把锁<ul>
<li>可重入：同一个线程可以多次获取同一把锁。比如一个方法a要去调一个方法b，在方法a中要先去获取锁，然后执行业务去调b，而b里又要去获取同一把锁。这种情况，如果锁是不可重入的，方法b中获取锁显然是会失败的，此时b会等待锁的释放，而锁又无法释放，因为方法a还没执行完，于是出现了<strong>死锁</strong>。</li>
</ul>
</li>
<li>不可重试：获取锁只尝试一次就返回false，没有重试机制</li>
<li>超时释放：锁超时释放虽然可以避免死锁，但如果业务执行耗时较长，也会导致锁释放，存在安全隐患。<ul>
<li>锁时间设置得太短，业务还么执行完，锁就释放了，导致其他业务也可能在同步执行中；如果设置过长，会导致其他业务等待时间长，阻塞周期长。</li>
</ul>
</li>
<li>主从一致性：如果Redis提供了主从集群，主从同步存在延迟，当主宕机，如果从并同步主中的锁数据，则会出现锁实现。<ul>
<li>比如有一个线程在主节点获取了锁（因为是用setnx实现，实际上是一个写操作），尚未将这个写操作同步给从节点时，存在延迟，突然主节点就宕机了，此时会选择一个从节点作为主节点，因为这个从节点尚未完成同步，没有锁这个标识，所以其他线程可以趁虚而入，拿到锁。</li>
</ul>
</li>
</ul>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网络。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包括了各种分布式锁的实现。</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504091048704.png" alt=""></p>
<p>官网：<a target="_blank" rel="noopener" href="https://redisson.pro/docs/">https://redisson.pro/docs/</a></p>
<h4 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h4><p>1.引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2.配置Redisson客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Redissonclient <span class="title function_">redissonclient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//配置类</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        <span class="comment">//添加redis地址，这里添加了单点的地址，也可以使用config.useClusterServers()添加集群地址</span></span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.150.101:6379&quot;</span>).setPassowrd(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">//创建客户端</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.使用Redisson的分布式锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testRedisson</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//获取锁（可重入），指定锁的名称</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonclient.getLock(<span class="string">&quot;anyLock&quot;</span>);</span><br><span class="line">    <span class="comment">//尝试获取锁，参数分别是，获取锁的最大等待时间（期间会重试），锁自动释放时间，时间单位</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1</span>,<span class="number">10</span>,TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//判断释放政取成功</span></span><br><span class="line">    <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行业务&quot;</span>)；</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Redisson可重入锁原理"><a href="#Redisson可重入锁原理" class="headerlink" title="Redisson可重入锁原理"></a>Redisson可重入锁原理</h4><p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504091928597.png" alt=""></p>
<p>重置锁有效期是为了给后续业务留下时间。</p>
<p>以上存在着多个步骤，要采用lua脚本实现，确保原子性。</p>
<h4 id="Redisson分布式锁原理"><a href="#Redisson分布式锁原理" class="headerlink" title="Redisson分布式锁原理"></a>Redisson分布式锁原理</h4><p><code>public boolean tryLock(long waitTime, long leaseTime, TimeUnit unit) throws InterruptedException &#123;&#125;</code></p>
<p> 参数：</p>
<ul>
<li>waitTime：<strong>尝试获取锁的最大等待时间</strong><ul>
<li>如果锁当前被其他线程持有，调用线程会持续尝试获取锁，直到超过<code>waitTime</code>设定的时长。若在此期间仍未获得锁，则返回<code>false</code>。</li>
</ul>
</li>
<li>leaseTime：<strong>锁的持有时间</strong><ul>
<li>成功获取锁后，锁会在<code>leaseTime</code>时长后自动释放，即使业务逻辑未执行完毕。若<code>leaseTime=-1</code>，则锁不会自动释放，需通过<code>unlock()</code>显式释放，此时Redisson的看门狗机制（WatchDog）会自动续期锁，防止死锁。</li>
</ul>
</li>
<li>unit：时间单位，用于统一<code>waitTime</code>和<code>leaseTime</code>的时间尺度</li>
</ul>
<h5 id="源码追溯（看门狗）"><a href="#源码追溯（看门狗）" class="headerlink" title="源码追溯（看门狗）"></a>源码追溯（看门狗）</h5><p>基于jdk1.8</p>
<h6 id="tryLock-源码解析"><a href="#tryLock-源码解析" class="headerlink" title="tryLock()源码解析"></a>tryLock()源码解析</h6><p>RedissonLock.class中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> waitTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.tryLock(waitTime, -<span class="number">1L</span>, unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>重试机制剖析</strong>：</p>
<p>点击tryLock()</p>
<p>:point_down: </p>
<p>RedissonLock.class中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> unit.toMillis(waitTime);  <span class="comment">// 可以看到先将等待时间转换成了毫秒</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> System.currentTimeMillis();  <span class="comment">// 得到当前时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();  <span class="comment">// 得到线程id，其实就是以后锁里的线程标识</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">ttl</span> <span class="operator">=</span> <span class="built_in">this</span>.tryAcquire(waitTime, leaseTime, unit, threadId);  <span class="comment">// 尝试获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        time -= System.currentTimeMillis() - current;</span><br><span class="line">        <span class="keyword">if</span> (time &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = System.currentTimeMillis();</span><br><span class="line">            RFuture&lt;RedissonLockEntry&gt; subscribeFuture = <span class="built_in">this</span>.subscribe(threadId);</span><br><span class="line">            <span class="keyword">if</span> (!subscribeFuture.await(time, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!subscribeFuture.cancel(<span class="literal">false</span>)) &#123;</span><br><span class="line">                    subscribeFuture.onComplete((res, e) -&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="built_in">this</span>.unsubscribe(subscribeFuture, threadId);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    time -= System.currentTimeMillis() - current;</span><br><span class="line">                    <span class="keyword">if</span> (time &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">                        <span class="type">boolean</span> <span class="variable">var20</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">return</span> var20;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="type">boolean</span> var16;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                            ttl = <span class="built_in">this</span>.tryAcquire(waitTime, leaseTime, unit, threadId);</span><br><span class="line">                            <span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">                                var16 = <span class="literal">true</span>;</span><br><span class="line">                                <span class="keyword">return</span> var16;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            time -= System.currentTimeMillis() - currentTime;</span><br><span class="line">                            <span class="keyword">if</span> (time &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                                <span class="built_in">this</span>.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">                                var16 = <span class="literal">false</span>;</span><br><span class="line">                                <span class="keyword">return</span> var16;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            currentTime = System.currentTimeMillis();</span><br><span class="line">                            <span class="keyword">if</span> (ttl &gt;= <span class="number">0L</span> &amp;&amp; ttl &lt; time) &#123;</span><br><span class="line">                                ((RedissonLockEntry)subscribeFuture.getNow()).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                ((RedissonLockEntry)subscribeFuture.getNow()).getLatch().tryAcquire(time, TimeUnit.MILLISECONDS);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            time -= System.currentTimeMillis() - currentTime;</span><br><span class="line">                        &#125; <span class="keyword">while</span>(time &gt; <span class="number">0L</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">this</span>.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">                        var16 = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">return</span> var16;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.unsubscribe(subscribeFuture, threadId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击tryAcquire()</p>
<p>:point_down:</p>
<p>RedissonLock.class中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Long <span class="title function_">tryAcquire</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (Long)<span class="built_in">this</span>.get(<span class="built_in">this</span>.tryAcquireAsync(waitTime, leaseTime, unit, threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击tryAcquireAsync()</p>
<p>:point_down:</p>
<p>RedissonLock.class中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; RFuture&lt;Long&gt; <span class="title function_">tryAcquireAsync</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1L</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果leaseTime有值，就用给的leaseTime值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 无值，就使用默认值，getLockWatchdogTimeout()，看门狗超时时间</span></span><br><span class="line">        RFuture&lt;Long&gt; ttlRemainingFuture = <span class="built_in">this</span>.tryLockInnerAsync(waitTime, <span class="built_in">this</span>.commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">        <span class="comment">// 当回调成功时进来，e代表异常，ttlRemaining表示剩余有效期</span></span><br><span class="line">        ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ttlRemaining == <span class="literal">null</span>) &#123;</span><br><span class="line">                     <span class="comment">// 为null代表锁获取成功了</span></span><br><span class="line">                    <span class="built_in">this</span>.scheduleExpirationRenewal(threadId);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>追溯getLockWatchdogTimeout()</p>
<p>:point_down:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是在Config.class中</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getLockWatchdogTimeout</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.lockWatchdogTimeout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击lockWatchdogTimeout，以下是在Config.class中</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> lockWatchdogTimeout;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> keepPubSubOrder;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> decodeInExecutor;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> useScriptCache;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> minCleanUpDelay;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> maxCleanUpDelay;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> cleanUpKeysAmount;</span><br><span class="line"><span class="keyword">private</span> NettyHook nettyHook;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> useThreadClassLoader;</span><br><span class="line"><span class="keyword">private</span> AddressResolverGroupFactory addressResolverGroupFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Config</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.transportMode = TransportMode.NIO;</span><br><span class="line">    <span class="built_in">this</span>.lockWatchdogTimeout = <span class="number">30000L</span>;  <span class="comment">// 可以看到，默认时间是30s</span></span><br><span class="line">    <span class="built_in">this</span>.keepPubSubOrder = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">this</span>.decodeInExecutor = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">this</span>.useScriptCache = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">this</span>.minCleanUpDelay = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">this</span>.maxCleanUpDelay = <span class="number">1800</span>;</span><br><span class="line">    <span class="built_in">this</span>.cleanUpKeysAmount = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">this</span>.nettyHook = <span class="keyword">new</span> <span class="title class_">DefaultNettyHook</span>();</span><br><span class="line">    <span class="built_in">this</span>.useThreadClassLoader = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">this</span>.addressResolverGroupFactory = <span class="keyword">new</span> <span class="title class_">DnsAddressResolverGroupFactory</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击tryAcquireAsync中的tryLockInnerAsync</p>
<p>:point_down:</p>
<p>RedissonLock.class中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; RFuture&lt;T&gt; <span class="title function_">tryLockInnerAsync</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> &#123;</span><br><span class="line">    <span class="comment">// 先把锁释放时间记录到本地的一个成员变量，叫做内部锁释放时间</span></span><br><span class="line">    <span class="built_in">this</span>.internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line">    <span class="comment">// 接着执行以下这段脚本</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    	脚本先是判断锁是否存在，如果不存在，就去记录锁的标识并且次数加一，然后设置锁的有效期，返回nil；</span></span><br><span class="line"><span class="comment">    	如果存在，就先判断锁是不是自己的，如果是自己的，锁重试次数加一，并且设置有效期，返回nil；</span></span><br><span class="line"><span class="comment">    	以上两种情况都是获取锁成功的情况，返回的都是nil，失败了返回一个结果，pttl和ttl效果类似，都是获取指定key剩余有效期，只不过ttl返回的是以秒为单位，而pttl返回的是以毫秒为单位。</span></span><br><span class="line"><span class="comment">    	所以失败返回的是锁的剩余有效期。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.evalWriteAsync(<span class="built_in">this</span>.getName(), LongCodec.INSTANCE, command, <span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); return nil; end; if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); return nil; end; return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span>, Collections.singletonList(<span class="built_in">this</span>.getName()), <span class="built_in">this</span>.internalLockLeaseTime, <span class="built_in">this</span>.getLockName(threadId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> CommandBatchService <span class="title function_">createCommandBatchService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.commandExecutor <span class="keyword">instanceof</span> CommandBatchService) &#123;</span><br><span class="line">        <span class="keyword">return</span> (CommandBatchService)<span class="built_in">this</span>.commandExecutor;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">MasterSlaveEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="built_in">this</span>.commandExecutor.getConnectionManager().getEntry(<span class="built_in">this</span>.getName());</span><br><span class="line">        <span class="type">BatchOptions</span> <span class="variable">options</span> <span class="operator">=</span> BatchOptions.defaults().syncSlaves(entry.getAvailableSlaves(), <span class="number">1L</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommandBatchService</span>(<span class="built_in">this</span>.commandExecutor.getConnectionManager(), options);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>往回倒到tryAcquireAsync()中</p>
<p>:point_up:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; RFuture&lt;Long&gt; <span class="title function_">tryAcquireAsync</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1L</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果leaseTime有值，就用给的leaseTime值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 无值，就使用默认值，getLockWatchdogTimeout()，看门狗超时时间</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	从上面的分析知，tryLockInnerAsync返回的是一个剩余有效期，这个结果是封装在Future里面的，因为这个函数是一个异步函数（Async），代表函数执行完代表命令发出去了，结果拿没拿到还不清楚</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        RFuture&lt;Long&gt; ttlRemainingFuture = <span class="built_in">this</span>.tryLockInnerAsync(waitTime, <span class="built_in">this</span>.commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">        <span class="comment">// 当回调成功时进来，e代表异常，ttlRemaining表示剩余有效期</span></span><br><span class="line">        ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ttlRemaining == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 为null代表锁获取成功了</span></span><br><span class="line">                    <span class="built_in">this</span>.scheduleExpirationRenewal(threadId);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 最终返回的也是一个Future</span></span><br><span class="line">        <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>往回倒到tryAcquire()中</p>
<p>:point_up:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Long <span class="title function_">tryAcquire</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">	<span class="comment">// 此处有个get，其实就是阻塞等待Future的结果，等待里面得到的剩余有效期</span></span><br><span class="line">    <span class="keyword">return</span> (Long)<span class="built_in">this</span>.get(<span class="built_in">this</span>.tryAcquireAsync(waitTime, leaseTime, unit, threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>往回倒到tryLock()中</p>
<p>:point_up:</p>
<p>就是最初进来的地方</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> unit.toMillis(waitTime);  <span class="comment">// 可以看到先将等待时间转换成了毫秒</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> System.currentTimeMillis();  <span class="comment">// 得到当前时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();  <span class="comment">// 得到线程id，其实就是以后锁里的线程标识</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">ttl</span> <span class="operator">=</span> <span class="built_in">this</span>.tryAcquire(waitTime, leaseTime, unit, threadId);  <span class="comment">// 尝试获取锁，得到的结果有两种，一种是null，代表获取锁成功；一种是锁的剩余有效期，代表获取锁失败。</span></span><br><span class="line">    <span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取锁这一段消耗的时间</span></span><br><span class="line">        time -= System.currentTimeMillis() - current;</span><br><span class="line">        <span class="keyword">if</span> (time &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = System.currentTimeMillis();</span><br><span class="line">            <span class="comment">// 订阅别人释放锁的信号，收到通知的时间是不确定的，所以这里也用Future存储</span></span><br><span class="line">            RFuture&lt;RedissonLockEntry&gt; subscribeFuture = <span class="built_in">this</span>.subscribe(threadId);</span><br><span class="line">            <span class="comment">// 如果等到这个最大剩余时间（time）结束，还没有收到释放锁的通知，则返回false</span></span><br><span class="line">            <span class="keyword">if</span> (!subscribeFuture.await(time, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!subscribeFuture.cancel(<span class="literal">false</span>)) &#123;</span><br><span class="line">                    subscribeFuture.onComplete((res, e) -&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 超时了，取消订阅</span></span><br><span class="line">                            <span class="built_in">this</span>.unsubscribe(subscribeFuture, threadId);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">                <span class="comment">// 返回false，获取锁失败</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 在这个最大剩余时间以内，获得了释放锁的通知</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 减去等待订阅的时间，得到现在的剩余等待时间</span></span><br><span class="line">                    time -= System.currentTimeMillis() - current;</span><br><span class="line">                    <span class="keyword">if</span> (time &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">                        <span class="type">boolean</span> <span class="variable">var20</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">return</span> var20;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="type">boolean</span> var16;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                            <span class="comment">// 第一次重试</span></span><br><span class="line">                            ttl = <span class="built_in">this</span>.tryAcquire(waitTime, leaseTime, unit, threadId);</span><br><span class="line">                            <span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">                                var16 = <span class="literal">true</span>;</span><br><span class="line">                                <span class="keyword">return</span> var16;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 再看一下剩余时间是多少</span></span><br><span class="line">                            time -= System.currentTimeMillis() - currentTime;</span><br><span class="line">                            <span class="keyword">if</span> (time &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                                <span class="built_in">this</span>.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">                                var16 = <span class="literal">false</span>;</span><br><span class="line">                                <span class="keyword">return</span> var16;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            currentTime = System.currentTimeMillis();</span><br><span class="line">                            <span class="keyword">if</span> (ttl &gt;= <span class="number">0L</span> &amp;&amp; ttl &lt; time) &#123;</span><br><span class="line">                                <span class="comment">// 使用getLatch，信号量的方法，释放锁的人将来会释放一个信号，这边就会尝试获取，尝试获取也有一个最大等待时间 </span></span><br><span class="line">                                ((RedissonLockEntry)subscribeFuture.getNow()).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                ((RedissonLockEntry)subscribeFuture.getNow()).getLatch().tryAcquire(time, TimeUnit.MILLISECONDS);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            time -= System.currentTimeMillis() - currentTime;</span><br><span class="line">                        &#125; <span class="keyword">while</span>(time &gt; <span class="number">0L</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">this</span>.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">                        var16 = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">return</span> var16;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.unsubscribe(subscribeFuture, threadId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从RedissonLock.java中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; RFuture&lt;Long&gt; <span class="title function_">tryAcquireAsync</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1L</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果leaseTime有值，就用给的leaseTime值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 无值，就使用默认值，getLockWatchdogTimeout()，看门狗超时时间</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	从上面的分析知，tryLockInnerAsync返回的是一个剩余有效期，这个结果是封装在Future里面的，因为这个函数是一个异步函数（Async），代表函数执行完代表命令发出去了，结果拿没拿到还不清楚</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        RFuture&lt;Long&gt; ttlRemainingFuture = <span class="built_in">this</span>.tryLockInnerAsync(waitTime, <span class="built_in">this</span>.commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">        <span class="comment">// 当回调成功时进来，e代表异常，ttlRemaining表示剩余有效期</span></span><br><span class="line">        ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ttlRemaining == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 为null代表锁获取成功了</span></span><br><span class="line">                    <span class="built_in">this</span>.scheduleExpirationRenewal(threadId);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 最终返回的也是一个Future</span></span><br><span class="line">        <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击scheduleExpirationRenewal()</p>
<p>:point_down:</p>
<p>RedissonLock.class中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scheduleExpirationRenewal</span><span class="params">(<span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="type">ExpirationEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExpirationEntry</span>();</span><br><span class="line">    <span class="comment">// 这个map的键是字符串，值是entry，map是静态的（private static final），也就是说RedissonLock创建的所有实例都能看到这个map，一个锁对应一个entry</span></span><br><span class="line">    <span class="comment">// putIfAbsent,如果存在就不执行，是第一次就会创建一个entry，如果是重入就会返回旧的entry</span></span><br><span class="line">    <span class="comment">// map的效果：保证同一个锁拿到的是同一个entry</span></span><br><span class="line">    <span class="type">ExpirationEntry</span> <span class="variable">oldEntry</span> <span class="operator">=</span> (ExpirationEntry)EXPIRATION_RENEWAL_MAP.putIfAbsent(<span class="built_in">this</span>.getEntryName(), entry);</span><br><span class="line">    <span class="keyword">if</span> (oldEntry != <span class="literal">null</span>) &#123;</span><br><span class="line">        oldEntry.addThreadId(threadId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        entry.addThreadId(threadId);</span><br><span class="line">        <span class="comment">// 第一次来会续约，更新有效期</span></span><br><span class="line">        <span class="built_in">this</span>.renewExpiration();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击getEntryName()</p>
<p>:point_down:</p>
<p>RedissonLock.class中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">RedissonLock</span><span class="params">(CommandAsyncExecutor commandExecutor, String name)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(commandExecutor, name);</span><br><span class="line">    <span class="built_in">this</span>.commandExecutor = commandExecutor;</span><br><span class="line">    <span class="built_in">this</span>.id = commandExecutor.getConnectionManager().getId();</span><br><span class="line">    <span class="built_in">this</span>.internalLockLeaseTime = commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout();</span><br><span class="line">    <span class="comment">// id是当前连接的id，name是当前锁的名称</span></span><br><span class="line">    <span class="built_in">this</span>.entryName = <span class="built_in">this</span>.id + <span class="string">&quot;:&quot;</span> + name;</span><br><span class="line">    <span class="built_in">this</span>.pubSub = commandExecutor.getConnectionManager().getSubscribeService().getLockPubSub();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> String <span class="title function_">getEntryName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 发现entryName是当前类的成员变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.entryName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到上一步，scheduleExpirationRenewal()中，点击renewExpiration()</p>
<p>:point_down:</p>
<p>RedissonLock.class中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renewExpiration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 先从map中得到entry</span></span><br><span class="line">    <span class="type">ExpirationEntry</span> <span class="variable">ee</span> <span class="operator">=</span> (ExpirationEntry)EXPIRATION_RENEWAL_MAP.get(<span class="built_in">this</span>.getEntryName());</span><br><span class="line">    <span class="keyword">if</span> (ee != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Timeout是一个超时任务（定时任务），delay时间后执行任务</span></span><br><span class="line">        <span class="type">Timeout</span> <span class="variable">task</span> <span class="operator">=</span> <span class="built_in">this</span>.commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="type">ExpirationEntry</span> <span class="variable">ent</span> <span class="operator">=</span> (ExpirationEntry)RedissonLock.EXPIRATION_RENEWAL_MAP.get(RedissonLock.<span class="built_in">this</span>.getEntryName());</span><br><span class="line">                <span class="keyword">if</span> (ent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">Long</span> <span class="variable">threadId</span> <span class="operator">=</span> ent.getFirstThreadId();</span><br><span class="line">                    <span class="keyword">if</span> (threadId != <span class="literal">null</span>) &#123;</span><br><span class="line">                        RFuture&lt;Boolean&gt; future = RedissonLock.<span class="built_in">this</span>.renewExpirationAsync(threadId);</span><br><span class="line">                        future.onComplete((res, e) -&gt; &#123;</span><br><span class="line">                            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                                RedissonLock.log.error(<span class="string">&quot;Can&#x27;t update lock &quot;</span> + RedissonLock.<span class="built_in">this</span>.getName() + <span class="string">&quot; expiration&quot;</span>, e);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                                    <span class="comment">// 调用自己，实现递归</span></span><br><span class="line">                                    RedissonLock.<span class="built_in">this</span>.renewExpiration();</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="built_in">this</span>.internalLockLeaseTime / <span class="number">3L</span>, TimeUnit.MILLISECONDS);  <span class="comment">// 之前看门狗时间被赋值到了internalLockLeaseTime，所以是10s</span></span><br><span class="line">        <span class="comment">// 最后把任务封装到这个entry中</span></span><br><span class="line">        ee.setTimeout(task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击renewExpirationAsync()</p>
<p>:point_down:</p>
<p>RedissonLock.class中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title function_">renewExpirationAsync</span><span class="params">(<span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="comment">// 执行脚本，作用是重置有效期</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.evalWriteAsync(<span class="built_in">this</span>.getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN, <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); return 1; end; return 0;&quot;</span>, Collections.singletonList(<span class="built_in">this</span>.getName()), <span class="built_in">this</span>.internalLockLeaseTime, <span class="built_in">this</span>.getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上两步可以发现，执行renewExpiration()会创建定时任务，10s后会重置有效期，然后调用自己，同样的，会创建定时任务，10s后会重置有效期，继续调用自己，那么这个任务会一直执行下去，这个锁的有效期会不断重置。最后把任务封装到这个entry中。</p>
<p>综上所述，entry里面包含线程id和任务</p>
<p>回到scheduleExpirationRenewal()中</p>
<p>:point_up_2:</p>
<p>RedissonLock.class</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scheduleExpirationRenewal</span><span class="params">(<span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="type">ExpirationEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExpirationEntry</span>();</span><br><span class="line">    <span class="comment">// 这个map的键是字符串，值是entry，map是静态的（private static final），也就是说RedissonLock创建的所有实例都能看到这个map，一个锁对应一个entry</span></span><br><span class="line">    <span class="comment">// putIfAbsent,如果存在就不执行，是第一次就会创建一个entry，如果是重入就会返回旧的entry</span></span><br><span class="line">    <span class="comment">// map的效果：保证同一个锁拿到的是同一个entry</span></span><br><span class="line">    <span class="type">ExpirationEntry</span> <span class="variable">oldEntry</span> <span class="operator">=</span> (ExpirationEntry)EXPIRATION_RENEWAL_MAP.putIfAbsent(<span class="built_in">this</span>.getEntryName(), entry);</span><br><span class="line">    <span class="keyword">if</span> (oldEntry != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 因为oldEntry存在该定时任务，所以不用执行this.renewExpiration();</span></span><br><span class="line">        oldEntry.addThreadId(threadId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        entry.addThreadId(threadId);</span><br><span class="line">        <span class="comment">// 第一次来会续约，更新有效期</span></span><br><span class="line">        <span class="built_in">this</span>.renewExpiration();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为oldEntry存在该定时任务，所以不用执行this.renewExpiration();</p>
<p>以上就是获取锁的逻辑（tryLock）</p>
<h6 id="unlock-源码解析"><a href="#unlock-源码解析" class="headerlink" title="unlock()源码解析"></a>unlock()源码解析</h6><p>点击unlock()，选择实现，选择RedissonLock</p>
<p>点击unlockAsync()</p>
<p>:point_down:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> RFuture&lt;Void&gt; <span class="title function_">unlockAsync</span><span class="params">(<span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    RPromise&lt;Void&gt; result = <span class="keyword">new</span> <span class="title class_">RedissonPromise</span>();</span><br><span class="line">    RFuture&lt;Boolean&gt; future = <span class="built_in">this</span>.unlockInnerAsync(threadId);</span><br><span class="line">    future.onComplete((opStatus, e) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 取消更新任务</span></span><br><span class="line">        <span class="built_in">this</span>.cancelExpirationRenewal(threadId);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            result.tryFailure(e);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opStatus == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">IllegalMonitorStateException</span> <span class="variable">cause</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>(<span class="string">&quot;attempt to unlock lock, not locked by current thread by node id: &quot;</span> + <span class="built_in">this</span>.id + <span class="string">&quot; thread-id: &quot;</span> + threadId);</span><br><span class="line">            result.tryFailure(cause);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.trySuccess((Object)<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击cancelExpirationRenewal()</p>
<p>:point_down:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">cancelExpirationRenewal</span><span class="params">(Long threadId)</span> &#123;</span><br><span class="line">    <span class="comment">// 取到当前这把锁的定时任务</span></span><br><span class="line">    <span class="type">ExpirationEntry</span> <span class="variable">task</span> <span class="operator">=</span> (ExpirationEntry)EXPIRATION_RENEWAL_MAP.get(<span class="built_in">this</span>.getEntryName());</span><br><span class="line">    <span class="keyword">if</span> (task != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (threadId != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 移除id</span></span><br><span class="line">            task.removeThreadId(threadId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (threadId == <span class="literal">null</span> || task.hasNoThreads()) &#123;</span><br><span class="line">            <span class="comment">// 取出任务</span></span><br><span class="line">            <span class="type">Timeout</span> <span class="variable">timeout</span> <span class="operator">=</span> task.getTimeout();</span><br><span class="line">            <span class="keyword">if</span> (timeout != <span class="literal">null</span>) &#123;</span><br><span class="line">                timeout.cancel();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            EXPIRATION_RENEWAL_MAP.remove(<span class="built_in">this</span>.getEntryName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504101618373.png" alt=""></p>
<ul>
<li>可重入：利用hash结构记录线程id和重入次数</li>
<li>可重试：利用信号量和PubSub功能实现等待、唤醒，获取锁失败的重试机制</li>
<li>超时续约：利用watchDog，每隔一段时间（releaseTime/3），重置超时时间</li>
</ul>
<h4 id="Redisson的multiLock原理"><a href="#Redisson的multiLock原理" class="headerlink" title="Redisson的multiLock原理"></a>Redisson的multiLock原理</h4><p>Redisson分布式锁主从一致性问题：</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504101623204.png" alt=""></p>
<p>每一个节点都获取锁才算成功。</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504101625720.png" alt=""></p>
<h5 id="源码溯源"><a href="#源码溯源" class="headerlink" title="源码溯源"></a>源码溯源</h5><p>点击tryLock()，点击实现，选择RedissonMultiLock</p>
<p>:point_down:</p>
<p>RedissonMultiLock.class</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> waitTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 此处leaseTime是-1，因为没传，如果传了就是传入的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.tryLock(waitTime, -<span class="number">1L</span>, unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击tryLock()</p>
<p>:point_down:</p>
<p>RedissonMultiLock.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">newLeaseTime</span> <span class="operator">=</span> -<span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1L</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (waitTime == -<span class="number">1L</span>) &#123;</span><br><span class="line">            <span class="comment">// waitTime为-1说明只想获取一次，不重试</span></span><br><span class="line">            newLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 释放时间会更新成等待时间的两倍，因为重试可能耗时较久，如果释放时间小于等待时间，会出现还没重试完就释放的情况。</span></span><br><span class="line">            newLeaseTime = unit.toMillis(waitTime) * <span class="number">2L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// remainTime初始化为-1</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">remainTime</span> <span class="operator">=</span> -<span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">if</span> (waitTime != -<span class="number">1L</span>) &#123;</span><br><span class="line">        <span class="comment">// 有等待时间，则剩余时间等于等待时间</span></span><br><span class="line">        remainTime = unit.toMillis(waitTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">lockWaitTime</span> <span class="operator">=</span> <span class="built_in">this</span>.calcLockWaitTime(remainTime);</span><br><span class="line">    <span class="type">int</span> <span class="variable">failedLocksLimit</span> <span class="operator">=</span> <span class="built_in">this</span>.failedLocksLimit();</span><br><span class="line">    <span class="comment">// 获取成功的锁的集合</span></span><br><span class="line">    List&lt;RLock&gt; acquiredLocks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(<span class="built_in">this</span>.locks.size());</span><br><span class="line">    ListIterator&lt;RLock&gt; iterator = <span class="built_in">this</span>.locks.listIterator();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有的锁</span></span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> (RLock)iterator.next();</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> lockAcquired;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (waitTime == -<span class="number">1L</span> &amp;&amp; leaseTime == -<span class="number">1L</span>) &#123;</span><br><span class="line">                lockAcquired = lock.tryLock();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">awaitTime</span> <span class="operator">=</span> Math.min(lockWaitTime, remainTime);</span><br><span class="line">                lockAcquired = lock.tryLock(awaitTime, newLeaseTime, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RedisResponseTimeoutException var21) &#123;</span><br><span class="line">            <span class="built_in">this</span>.unlockInner(Arrays.asList(lock));</span><br><span class="line">            lockAcquired = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var22) &#123;</span><br><span class="line">            lockAcquired = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// lockAcquired代表获取锁是否成功</span></span><br><span class="line">        <span class="keyword">if</span> (lockAcquired) &#123;</span><br><span class="line">            acquiredLocks.add(lock);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// else是获取锁失败的逻辑</span></span><br><span class="line">            <span class="comment">// 当前锁的数量-获取成功锁的数量，failedLocksLimit()通过之后的源码可以看到为0，没所以意思就是所有锁都获取成功之后break</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.locks.size() - acquiredLocks.size() == <span class="built_in">this</span>.failedLocksLimit()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (failedLocksLimit == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.unlockInner(acquiredLocks);</span><br><span class="line">                <span class="keyword">if</span> (waitTime == -<span class="number">1L</span>) &#123;</span><br><span class="line">                    <span class="comment">// 不想重试</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                failedLocksLimit = <span class="built_in">this</span>.failedLocksLimit();</span><br><span class="line">                <span class="comment">// 将拿到的锁清空</span></span><br><span class="line">                acquiredLocks.clear();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(iterator.hasPrevious()) &#123;</span><br><span class="line">                    <span class="comment">// 将迭代器的指针指到第一个</span></span><br><span class="line">                    iterator.previous();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                --failedLocksLimit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (remainTime != -<span class="number">1L</span>) &#123;</span><br><span class="line">            <span class="comment">// 计算获取锁的耗时</span></span><br><span class="line">            remainTime -= System.currentTimeMillis() - time;</span><br><span class="line">            time = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (remainTime &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                <span class="comment">// 等待时间耗尽，超时，释放已经获得的锁</span></span><br><span class="line">                <span class="built_in">this</span>.unlockInner(acquiredLocks);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// leaseTime为-1时，会触发看门狗机制，所以不需要对每把锁设置有效期</span></span><br><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1L</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置了leaseTime</span></span><br><span class="line">        List&lt;RFuture&lt;Boolean&gt;&gt; futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(acquiredLocks.size());</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">var24</span> <span class="operator">=</span> acquiredLocks.iterator();</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 遍历所有成功拿到的锁，expireAsync()设置有效期，确保了所有锁的有效期是一样的</span></span><br><span class="line">        <span class="comment">// 这么做的原因，第一把拿到的锁马上就进行倒计时了，最后拿到的一把锁是刚开始倒计时，就会导致第一把的剩余有效期比最后一把短，就会导致有些释放了有些没释放。</span></span><br><span class="line">        <span class="keyword">while</span>(var24.hasNext()) &#123;</span><br><span class="line">            <span class="type">RLock</span> <span class="variable">rLock</span> <span class="operator">=</span> (RLock)var24.next();</span><br><span class="line">            RFuture&lt;Boolean&gt; future = ((RedissonLock)rLock).expireAsync(unit.toMillis(leaseTime), TimeUnit.MILLISECONDS);</span><br><span class="line">            futures.add(future);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var24 = futures.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var24.hasNext()) &#123;</span><br><span class="line">            RFuture&lt;Boolean&gt; rFuture = (RFuture)var24.next();</span><br><span class="line">            rFuture.syncUninterruptibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点进calcLockWaitTime()</p>
<p>:point_down:</p>
<p>RedissonMultiLock.class中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">long</span> <span class="title function_">calcLockWaitTime</span><span class="params">(<span class="type">long</span> remainTime)</span> &#123;</span><br><span class="line">    <span class="comment">// 可以发现锁等待时间就是剩余时间</span></span><br><span class="line">    <span class="keyword">return</span> remainTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到前一步，点进failedLocksLimit()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">failedLocksLimit</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p>1)不可重入Redis分布式锁：</p>
<ul>
<li><p>原理：利用setnx的互斥性；利用ex避免死锁；释放锁时判<br>断线程标示</p>
</li>
<li><p>缺陷：不可重入、无法重试、锁超时失效</p>
</li>
</ul>
<p>2)可重入的Redis分布式锁：</p>
<ul>
<li>原理：利用hash结构，记录线程标示和重入次数；利用<br>watchDog延续锁时间；利用信号量控制锁重试等待</li>
<li>缺陷：redis宕机引起锁失效问题</li>
</ul>
<p>3)Redisson的multiLock:</p>
<ul>
<li>原理：多个独立的Redis节点，必须在所有节点都获取重入<br>锁，才算获取锁成功</li>
<li>缺陷：运维成本高、实现复杂</li>
</ul>
<h2 id="秒杀优化"><a href="#秒杀优化" class="headerlink" title="秒杀优化"></a>秒杀优化</h2><h3 id="异步秒杀"><a href="#异步秒杀" class="headerlink" title="异步秒杀"></a>异步秒杀</h3><p>优化前：</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504181328916.png" alt=""></p>
<p>业务串行执行，执行时间久。</p>
<p>优化策略：</p>
<ul>
<li>将判断秒杀资格和库存操作分离开来，分别交由两个线程操作</li>
<li>引入redis，不直接在数据库操作（数据库操作的性能没有redis高）</li>
</ul>
<p>优化后：</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504181331215.png" alt=""></p>
<h4 id="redis存储结构"><a href="#redis存储结构" class="headerlink" title="redis存储结构"></a>redis存储结构</h4><p>库存：string</p>
<p>订单：set（当前这个优惠券有多个用户，这些用户不能重复） </p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504181340474.png" alt=""></p>
<p>返回1，代表库存不充足；返回2，代表一人一单不成立；返回0，代表成功。要确保这段执行流程的原子性，所以采用lua脚本。</p>
<h3 id="基于Redis实现秒杀资格判断"><a href="#基于Redis实现秒杀资格判断" class="headerlink" title="基于Redis实现秒杀资格判断"></a>基于Redis实现秒杀资格判断</h3><p>需求：</p>
<ul>
<li>新增秒杀优惠券的同时，将优惠券信息保存到Redis中</li>
<li>基于Lua脚本，判断秒杀库存、一人一单，决定用户是否抢购成功</li>
<li>如果抢购成功，将优惠券id和用户id封装后存入阻塞队列</li>
<li>开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能</li>
</ul>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>秒杀业务的优化思路是什么？</p>
<ul>
<li>先利用Redis完成库存余量、一人一单判断，完成抢单业务</li>
<li>再将下单业务放入阻塞队列，利用独立线程异步下单</li>
</ul>
<p>基于阻塞队列的异步秒杀存在哪些问题？</p>
<ul>
<li>内存限制问题（阻塞队列长度有限）</li>
<li>数据安全问题（我们是基于内存来保存订单信息的，当服务宕机，内存里的订单全部丢失了，后台也没更新，出现了数据不一致问题；有一个线程从队列中取出一个下单任务要去执行，就在此时，发生了事故，这样一来，这个任务没有执行，而任务取出来，队列里也就没有了，也就是说以后再也不会执行了，又出现了数据不一致问题。）</li>
</ul>
<h2 id="Redis消息队列"><a href="#Redis消息队列" class="headerlink" title="Redis消息队列"></a>Redis消息队列</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>消息队列（Message Queue），字面意思就是存放消息的队列。最简单的消息队列模型包括三个角色。</p>
<ul>
<li>消息队列：存储和管理消息，也被称为消息代理（Message Broker）</li>
<li>生产者：发送消息到消息队列</li>
<li>消费者：从消息队列获取消息并处理消息</li>
</ul>
<p>消息队列和阻塞队列的区别：</p>
<ul>
<li><p>消息队列是在jvm以外的一个独立服务，不受jvm内存的限制。</p>
</li>
<li><p>消息队列不仅仅做数据的存储，还要确保数据的安全，存进消息队列的所有消息要做持久化（这样不管服务是重启还是宕机，数据不会丢失）。</p>
</li>
<li><p>它在消息投递给消费者之后，要求消费者做消息的确认，如果消息没有确认，那么这个消息就会在队列中依然存在，下一次会再次投递给消费者，让它再次处理，直到成功为止。（确保消息至少被消费一次）</p>
</li>
</ul>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504182000723.png" alt=""></p>
<p>Redis提供了三种不同的方式来实现消息队列：</p>
<ul>
<li>list结构：基List结构模拟消息队列</li>
<li>PubSub：基本的点对点消息模型</li>
<li>Stream：比较完善的消息队列模型</li>
</ul>
<p>微服务中常见的消息队列技术：RabbitMQ, Kafka</p>
<h3 id="基于List结构模拟消息队列"><a href="#基于List结构模拟消息队列" class="headerlink" title="基于List结构模拟消息队列"></a>基于List结构模拟消息队列</h3><p>队列是入口和出口不在一边，因此我们可以利用：LPUSH结合RPOP、或者RPUSH结合LPOP来实现。</p>
<p>不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null,并不像JVM的阻塞队列那样会阻塞并等待消息。<br>因此这里应该使用BRPOP或者BLPOP来实现阻塞效果。</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504182011089.png" alt=""></p>
<p>基于Lst的消息队列有哪些优缺点？<br>优点：</p>
<ul>
<li>利用Redis存储，不受限于JVM内存上限</li>
<li>基于Redis的持久化机制，数据安全性有保证，可以满足消息有序性</li>
</ul>
<p>缺点：</p>
<ul>
<li>无法避免消息丢失</li>
<li>只支持单消费者</li>
</ul>
<h3 id="基于PubSub的消息队列"><a href="#基于PubSub的消息队列" class="headerlink" title="基于PubSub的消息队列"></a>基于PubSub的消息队列</h3><p>PubSub（发布订阅)是Redis2.0版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个channel,生产者向对应channel发送消息后，所有订阅者都能收到相关消息。</p>
<ul>
<li>SUBSCRIBE channel[channel]:订阅一个或多个频道</li>
<li>PUBLISH channel msg:向一个频道发送消息</li>
<li>PSUBSCRIBE pattern[pattern]:订阅与pattern格式匹配的所有频道<ul>
<li>Supported glob-style patterns:<ul>
<li><code>h?llo</code> subscribes to <code>hello</code>, <code>hallo</code> and <code>hxllo</code></li>
<li><code>h*llo</code> subscribes to <code>hllo</code> and <code>heeeello</code></li>
<li><code>h[ae]llo</code> subscribes to <code>hello</code> and <code>hallo,</code> but not <code>hillo</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504182023410.png" alt=""></p>
<p>基于PubSub的消息队列有哪些优缺点？<br>优点：</p>
<ul>
<li>采用发布订阅模型，支持多生产、多消费</li>
</ul>
<p>缺点：</p>
<ul>
<li>不支持数据持久化（如果一个消息没有被任何人订阅，这个频道没有被任何人订阅，这个消息就直接丢失了）<ul>
<li>PubSub的实现不依赖任何具体的数据结构（如List或Stream），而是直接在内存中通过<strong>发布-订阅通道</strong>传递消息。这意味着：<ul>
<li>消息<strong>不会写入RDB快照或AOF日志</strong>，导致Redis宕机或重启时所有未消费的消息永久丢失。</li>
<li>消息仅存在于消费者连接期间，若消费者离线或断连，其未接收的消息会被直接丢弃。</li>
</ul>
</li>
</ul>
</li>
<li>无法避免消息丢失</li>
<li>消息堆积有上限，超出时数据丢失<ul>
<li>每个消费者连接在Redis服务端分配了一个内存缓冲区，用于暂存待推送的消息。该缓冲区存在明确的上限配置（如默认<code>client-output-buffer-limit pubsub 32mb 8mb 60</code>）。当消费者处理速度低于消息生产速度时，缓冲区内的消息会持续堆积。一旦超过配置的阈值（例如32MB内存上限或60秒超时），Redis会强制断开该消费者的连接，导致缓冲区中所有未处理的消息永久丢失。</li>
<li>PubSub采用纯实时转发模型，消息不会在服务端存储。生产者发布消息后，Redis仅将消息推送给当前已订阅的消费者，若消费者离线或处理不及时，消息无法留存，直接丢失。即使消费者重新连接，也无法获取断连期间的消息。</li>
</ul>
</li>
</ul>
<h3 id="基于Stream的消息队列"><a href="#基于Stream的消息队列" class="headerlink" title="基于Stream的消息队列"></a>基于Stream的消息队列</h3><p><strong>XADD</strong></p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504182051926.png" alt=""></p>
<p>同一毫秒的消息时间戳一样，后面的数字依次递增</p>
<p><strong>XREAD</strong></p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504182054214.png" alt=""></p>
<p>表示最新的消息 ID，<strong>仅在阻塞模式下有效</strong>。非阻塞模式下使用 <code>$</code> 无意义（非阻塞下会直接返回 <code>(nil)</code>，因为没有加 <code>BLOCK</code> 是直接返回的，即使是没有数据。）</p>
<p><strong>阻塞</strong></p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504182057737.png" alt=""></p>
<p>STREAM类型消息队列的XREAD命令特点：</p>
<ul>
<li><p>消息可回溯</p>
<ul>
<li>STREAM类型的消息队列默认将消息持久化存储在Redis中，即使消息已被消费，仍可通过XREAD命令重新读取。这与PubSub模型（消息不持久化）和List队列（消息弹出后删除）形成鲜明对比</li>
</ul>
</li>
<li><p>一个消息可以被多个消费者读取</p>
</li>
<li>可以阻塞读取</li>
<li>有消息漏读的风险</li>
</ul>
<h3 id="Stream的消费者组模式"><a href="#Stream的消费者组模式" class="headerlink" title="Stream的消费者组模式"></a>Stream的消费者组模式</h3><p>消费者组（Consumer Group):将多个消费者划分到一个组中，监听同一个队列。具备下列特点：</p>
<ul>
<li>消息分流：队列中的消息会分流给组内的不同消费者，而不是重复消费，从而加快消息处理的速度。</li>
<li>消息标示：消费者组会维护一个标示，记录最后一个被处理的消息，哪怕消费者宕机重启，还会从标示之后读取消息。确保每一个消息都会被消费。<ul>
<li>消费者组始终从标示之后读取消息，即使消费者宕机重启，也能从该位置继续消费，确保每条消息只会被处理一次</li>
</ul>
</li>
<li>消息确认：消费者获取消息后，消息处于pending状态，并存入一个<br>pending-list。当处理完成后需要通过XACK来确认消息，标记消息为已处理，才会从pendingList移除。<ul>
<li>消费者读取消息后，消息进入<code>pending-list</code>处于“未决状态”，若处理失败（如消费者崩溃），其他消费者可通过<code>XPENDING</code>查询并重新处理这些消息</li>
</ul>
</li>
</ul>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504182122915.png" alt=""></p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504182150891.png" alt=""></p>
<ul>
<li><code>&gt;</code>：仅读取未分配给组内其他消费者的新消息。</li>
<li><code>0</code> 或其他具体ID：读取已分配但未确认（Pending）的消息。</li>
</ul>
<p>转换为java伪代码：</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504182158992.png" alt=""></p>
<p><strong>总结：</strong></p>
<p>STREAM类型消息队列的XREADGROUP命令特点：</p>
<ul>
<li>消息可回溯<ul>
<li>消费者组会记录每个消费者最后处理的消息ID（通过<code>last_delivered_id</code>维护），即使消费者宕机或重启，也能从断点继续读取历史消息。此外，通过指定消息ID（如<code>0-0</code>表示从头读取）或访问<code>pending-list</code>（存放未确认消息），可以回溯处理未被确认或遗漏的消息</li>
</ul>
</li>
<li>可以多消费者争抢消息，加快消费速度<ul>
<li>消费者组（Consumer Group）将消息分发给组内不同消费者，实现负载均衡。例如，组内消费者<code>c1</code>和<code>c2</code>可以同时处理不同消息，避免单点瓶颈，显著提升吞吐量。Redis自动分配消息，确保每条消息仅被一个消费者处理</li>
</ul>
</li>
<li>可以阻塞读取<ul>
<li><code>XREADGROUP</code>支持<code>BLOCK</code>参数（如<code>BLOCK 2000</code>表示阻塞2秒），当没有新消息时，消费者会进入等待状态，直到新消息到达或超时。这种机制类似于<code>List</code>的阻塞弹出操作，但支持更灵活的流式处理</li>
</ul>
</li>
<li>没有消息漏读的风险<ul>
<li>消费者组通过维护消息处理状态（如<code>pending-list</code>）和消费者游标（<code>last_delivered_id</code>）确保消息不会漏读。即使消费者异常退出，未确认的消息会保留在<code>pending-list</code>中，后续可通过重新读取<code>0-0</code>或指定消息ID恢复处理，避免遗漏</li>
</ul>
</li>
<li>有消息确认机制，保证消息至少被消费一次<ul>
<li>消费者处理完消息后需发送<code>XACK</code>命令确认，否则消息会保留在<code>pending-list</code>中。若网络问题导致未确认，其他消费者可通过<code>XCLAIM</code>接管消息，或重新读取<code>pending-list</code>进行重试，从而保证至少被消费一次。但需注意重复消费的可能性，需业务端实现幂等性处理</li>
</ul>
</li>
</ul>
<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>List</th>
<th>PubSub</th>
<th>Stream</th>
</tr>
</thead>
<tbody>
<tr>
<td>消息持久化</td>
<td>支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>阻塞读取</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>消息堆积处理</td>
<td>受限于内存空间，可以利用多消费者加快处理</td>
<td>受限于消费者缓冲区</td>
<td>受限于队列长度，可以利用消费者组提高消费速度，减少堆积</td>
</tr>
<tr>
<td>消息确认机制</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>消息回溯</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
</tbody>
</table>
</div>
<h3 id="基于Stream消息队列实现异步秒杀"><a href="#基于Stream消息队列实现异步秒杀" class="headerlink" title="基于Stream消息队列实现异步秒杀"></a>基于Stream消息队列实现异步秒杀</h3><p>需求：</p>
<ul>
<li><p>创建一个Stream类型的消息队列，名为stream.orders</p>
<ul>
<li>在Redis命令行中创建，<code>redis-cli -a 123321</code></li>
<li>然后输入命令<code>XGROUP CREATE stream.orders g1 0 MKSTREAM</code></li>
</ul>
</li>
<li><p>修改之前的秒杀下单Lua脚本，在认定有抢购资格后，直接向stream.orders中添加消息，内容包含voucherld、userld、orderld</p>
</li>
<li>项目启动时，开启一个线程任务，尝试获取stream.orders中的消息，完成下单</li>
</ul>
<h2 id="达人探店"><a href="#达人探店" class="headerlink" title="达人探店"></a>达人探店</h2><p>点赞排行榜：</p>
<p>需求：按照点赞时间先后排序，返回Top5的用户</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>List</th>
<th>Set</th>
<th>SortedSet</th>
</tr>
</thead>
<tbody>
<tr>
<td>排序方式</td>
<td>按添加顺序排序</td>
<td>无法排序</td>
<td>根据score值排序</td>
</tr>
<tr>
<td>唯一性</td>
<td>不唯一</td>
<td>唯一</td>
<td>唯一</td>
</tr>
<tr>
<td>查找方式</td>
<td>按索引查找或首尾查找</td>
<td>根据元素查找</td>
<td>根据元素查找</td>
</tr>
</tbody>
</table>
</div>
<p>List：LPUSH+RPOP（建议使用这个，左侧为头，右侧为尾） RPUSH+LPOP</p>
<p><code>ZSCORE key member</code>：查询key对应的分数，如果key不存在返回空</p>
<p>点赞顺序不一致问题</p>
<p>问题描述：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,phone,password,nick_name,icon,create_time,update_time</span><br><span class="line"><span class="keyword">FROM</span> tb_user</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="number">5</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>传的id顺序是5 1，数据库查询的结果顺序是1 5</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504192104292.png" alt=""></p>
<p>这是因为SQL 的 <code>IN</code> 子句仅负责筛选数据，<strong>不会保证结果顺序</strong>。数据库默认按存储或索引顺序返回数据（通常是主键升序）。</p>
<p>解决办法：</p>
<p>要实现固定顺序 <code>5, 1</code>，需用 <code>ORDER BY</code> 显式排序。在 <strong>MySQL</strong> 中可配合 <code>FIELD()</code> 函数实现：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,phone,password,nick_name,icon,create_time,update_time</span><br><span class="line"><span class="keyword">FROM</span> tb_user</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="number">5</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> FIELD(id, <span class="number">5</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>代码改前：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.解析出其中的用户id</span></span><br><span class="line">List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line"><span class="comment">// 3.根据用户id查询用户</span></span><br><span class="line">List&lt;UserDTO&gt; userDTOS = userService.listByIds(ids)</span><br><span class="line">    .stream()</span><br><span class="line">    .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))</span><br><span class="line">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p>代码改后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.解析出其中的用户id</span></span><br><span class="line">List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line"><span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line"><span class="comment">// 3.根据用户id查询用户 Where id in (5, 1) order by field(id, 5, 1)</span></span><br><span class="line">List&lt;UserDTO&gt; userDTOS = userService.query()</span><br><span class="line">    .in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list()  <span class="comment">// 因为MyBatisPlus中没有支持order by field，所以使用.last后面拼接sql</span></span><br><span class="line">    .stream()</span><br><span class="line">    .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))</span><br><span class="line">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<h2 id="好友关注"><a href="#好友关注" class="headerlink" title="好友关注"></a>好友关注</h2><h3 id="关注和取关"><a href="#关注和取关" class="headerlink" title="关注和取关"></a>关注和取关</h3><p>需求：基于该表数据结构，实现两个接口：</p>
<ul>
<li>关注和取关接口</li>
<li>判断是否关注的接口</li>
</ul>
<h3 id="共同关注"><a href="#共同关注" class="headerlink" title="共同关注"></a>共同关注</h3><p>需求：利用Redis中恰当的数据结构，实现共同关注功能。在博主个人页面展示出当前用户与博主的共同好友。</p>
<h3 id="关注推送"><a href="#关注推送" class="headerlink" title="关注推送"></a>关注推送</h3><p>关注推送也叫做Feed流，直译为投喂。为用户持续的提供沉浸式的体验，通过无限下拉刷新获取新的信息。</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504201454815.png" alt=""></p>
<p>Feed流产品有两种常见模式：</p>
<ul>
<li>Timeline：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注。例如朋友圈<ul>
<li>优点：信息全面，不会有缺失。并且实现也相对简单</li>
<li>缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低</li>
</ul>
</li>
<li>智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容。推送用户感兴趣信息来吸引用户<ul>
<li>优点：投喂用户感兴趣信息，用户粘度很高，容易沉迷</li>
<li>缺点：如果算法不精准，可能起到反作用</li>
</ul>
</li>
</ul>
<p>本例中的个人页面，是基于关注的好友来做Feed流，因此采用Timeline的模式。该模式的实现方案有三种：<br>①拉模式<br>②推模式<br>③推拉结合</p>
<p><strong>拉模式：</strong>也叫读扩散。</p>
<p><strong>定义</strong>：用户主动拉取关注对象的最新动态。当用户请求Feed流时，系统需实时遍历其所有关注对象的发件箱（如个人页Timeline），聚合内容后按时间排序返回。<br><strong>优点</strong>：</p>
<ul>
<li><strong>存储压力小</strong>：无需为每个粉丝预存内容，仅需维护发布者的个人页Timeline。</li>
<li><strong>实现简单</strong>：逻辑清晰，适合初期用户量较少或关注关系稀疏的场景。<br><strong>缺点</strong>：</li>
<li><strong>延迟高</strong>：每次请求需遍历所有关注对象，导致响应时间长，尤其当用户关注数多时性能骤降。</li>
<li><strong>读取压力大</strong>：高并发场景下，频繁的聚合和排序操作可能压垮数据库。<br><strong>适用场景</strong>：</li>
<li>用户关注关系简单（如普通用户关注数较少）。</li>
<li>对实时性要求不高的系统初期阶段。</li>
</ul>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504201509032.png" alt=""></p>
<p><strong>推模式：</strong>也叫写扩散</p>
<p><strong>定义</strong>：用户发布动态时，系统立即将该动态推送给所有粉丝的收件箱（即关注页Timeline）。用户读取Feed流时直接获取预存内容，无需实时计算。<br><strong>优点</strong>：</p>
<ul>
<li><strong>实时性强</strong>：动态发布后立即触达粉丝，读取时直接返回预存结果，响应速度快。</li>
<li><strong>读取性能高</strong>：用户仅需访问自己的收件箱，避免复杂聚合操作。<br><strong>缺点</strong>：</li>
<li><strong>存储压力大</strong>：大V粉丝数庞大时，单条动态需写入数百万次，导致存储成本激增。</li>
<li><strong>数据冗余</strong>：非活跃用户可能长期不访问，预存内容浪费存储空间。<br><strong>适用场景</strong>：</li>
<li>用户关系均匀（如朋友圈，粉丝数有限）。</li>
<li>需要高实时性的场景（如即时社交动态）</li>
</ul>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504201506684.png" alt=""></p>
<p><strong>推拉结合：</strong>也叫读写混合，兼具推和拉两种模式的优点。</p>
<p><strong>定义</strong>：结合推、拉两种模式的优点，根据用户类型或活跃度差异化处理：</p>
<ul>
<li><strong>对大V采用拉模式</strong>：大V发布动态时，仅写入其个人页Timeline，粉丝读取时需合并大V和普通关注者的内容。</li>
<li><strong>对普通用户采用推模式</strong>：普通用户发布动态时，直接推送给粉丝的收件箱。</li>
<li><strong>按活跃度分流</strong>：对在线用户实时推送，离线用户登录后手动拉取更新。<br><strong>优点</strong>：</li>
<li><strong>平衡性能与存储</strong>：减少大V推送带来的存储压力，同时保证活跃用户的实时体验。</li>
<li><strong>灵活性高</strong>：可动态调整策略（如根据粉丝活跃度分级推送）。<br><strong>缺点</strong>：</li>
<li><strong>实现复杂</strong>：需维护两种逻辑（推和拉），增加系统设计和运维成本。</li>
<li><strong>合并开销</strong>：读取时需合并多个来源的数据，可能引入延迟。<br><strong>适用场景</strong>：</li>
<li>存在大量大V用户（如微博、抖音）。</li>
<li>用户活跃度差异显著，需优化资源分配的场景</li>
</ul>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504201508487.png" alt=""></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>拉模式</th>
<th>推模式</th>
<th>推拉结合</th>
</tr>
</thead>
<tbody>
<tr>
<td>写比例</td>
<td>低</td>
<td>高</td>
<td>中</td>
</tr>
<tr>
<td>读比例</td>
<td>高</td>
<td>低</td>
<td>中</td>
</tr>
<tr>
<td>用户读取延迟</td>
<td>高</td>
<td>低</td>
<td>中</td>
</tr>
<tr>
<td>实现难度</td>
<td>复杂</td>
<td>简单</td>
<td>很复杂</td>
</tr>
<tr>
<td>使用场景</td>
<td>很少使用</td>
<td>用户量少、没有大V</td>
<td>过千万的用户量，有大V</td>
</tr>
</tbody>
</table>
</div>
<h3 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h3><h3 id="基于推模式实现关注推送功能"><a href="#基于推模式实现关注推送功能" class="headerlink" title="基于推模式实现关注推送功能"></a>基于推模式实现关注推送功能</h3><p>需求：</p>
<p>①修改新增探店笔记的业务，在保存blog到数据库的同时，推送到粉丝的收件箱<br>②收件箱满足可以根据时间戳排序，必须用Redis的数据结构实现<br>③查询收件箱数据时，可以实现分页查询</p>
<h4 id="Feed流的分页问题"><a href="#Feed流的分页问题" class="headerlink" title="Feed流的分页问题"></a>Feed流的分页问题</h4><p>Feed流中的数据会不断更新，所以数据的角标也在变化，因此不能采用传统的分页模式。</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504201540089.png" alt=""></p>
<p>采用滚动分页。</p>
<p>记录每一次查询的最后一条，下一次查询的时候从这一条开始查。</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504201541606.png" alt=""></p>
<p>使用sortedset，score记录时间戳，每一次查询记录最后一条的时间戳，下一次查询的时候查询比这时间戳更小的。</p>
<p>总结：如果数据会变化做分页的话，用sortedset。</p>
<h3 id="实现关注推送页面的分页查询"><a href="#实现关注推送页面的分页查询" class="headerlink" title="实现关注推送页面的分页查询"></a>实现关注推送页面的分页查询</h3><p>需求：在个人主页的“关注”卡片中，查询并展示推送的Blog信息。</p>
<p><strong>ZRANGEBYSCORE：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span><br><span class="line">summary: Return a range of members <span class="keyword">in</span> a sorted <span class="built_in">set</span>, by score</span><br><span class="line">since: 1.0.5</span><br></pre></td></tr></table></figure>
<p><strong>必选参数</strong></p>
<ul>
<li><strong><code>key</code></strong>：有序集合的键名</li>
<li><strong><code>min</code></strong>：分数下限（支持 <code>-inf</code> 表示负无穷）</li>
<li><strong><code>max</code></strong>：分数上限（支持 <code>+inf</code> 表示正无穷）</li>
</ul>
<p><strong>可选参数</strong></p>
<ul>
<li><strong><code>WITHSCORES</code></strong>：返回成员及其分数值，格式为 <code>[成员1, 分数1, 成员2, 分数2...]</code></li>
<li><strong><code>LIMIT offset count</code></strong>：分页查询，<code>offset</code> 表示跳过前N个结果，<code>count</code> 表示返回的数量</li>
<li><strong>开区间语法</strong>：在 <code>min</code> 或 <code>max</code> 前加 <code>(</code> 符号表示开区间（如 <code>(1</code> 表示大于1）。</li>
</ul>
<p><strong>示例：</strong></p>
<p>假设有一个存储员工薪资的有序集合 <code>salary</code>，数据如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZADD salary 2000 &quot;john&quot; 3000 &quot;tom&quot; 4500 &quot;rose&quot; 6500 &quot;jack&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例1：获取整个范围的成员</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGEBYSCORE salary -inf +inf</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>结果</strong>：<code>[&quot;john&quot;, &quot;tom&quot;, &quot;rose&quot;, &quot;jack&quot;]</code></li>
<li>说明：-inf和+inf表示所有分数范围</li>
</ul>
<p><strong>示例2：获取闭区间内的成员</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGEBYSCORE salary 2000 4500</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>结果</strong>：<code>[&quot;john&quot;, &quot;tom&quot;, &quot;rose&quot;]</code></li>
<li><strong>说明</strong>：包含分数等于2000和4500的成员。</li>
</ul>
<p><strong>示例3：使用开区间</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGEBYSCORE salary (2000 4500</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>结果</strong>：<code>[&quot;tom&quot;, &quot;rose&quot;]</code></li>
<li><strong>说明</strong>：<code>(2000</code> 表示薪资大于2000，4500仍为闭区间。</li>
</ul>
<p><strong>示例4：分页查询</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGEBYSCORE salary -inf +inf LIMIT 1 2</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>结果</strong>：<code>[&quot;tom&quot;, &quot;rose&quot;]</code></li>
<li><strong>说明</strong>：跳过第1个成员（”john”），返回接下来的2个。</li>
</ul>
<p><strong>示例5：显示分数值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGEBYSCORE salary 2000 4500 WITHSCORES</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>结果</strong>：<code>[&quot;john&quot;, &quot;2000&quot;, &quot;tom&quot;, &quot;3000&quot;, &quot;rose&quot;, &quot;4500&quot;]</code></li>
<li><strong>说明</strong>：<code>WITHSCORES</code> 参数将分数一并返回。</li>
</ul>
<hr>
<p><strong>注意事项</strong></p>
<ol>
<li><strong>排序规则</strong>：结果按分数升序排列，相同分数的成员按字典序排序。</li>
<li><strong>参数顺序</strong>：<code>min</code> 必须在前，<code>max</code> 在后。若需降序，应使用 <code>ZREVRANGEBYSCORE</code>。</li>
<li><strong>性能</strong>：时间复杂度为 <code>O(log(N)+M)</code>，<code>N</code> 是集合成员数，<code>M</code> 是结果数量</li>
</ol>
<h4 id="滚动分页查询存在问题"><a href="#滚动分页查询存在问题" class="headerlink" title="滚动分页查询存在问题"></a>滚动分页查询存在问题</h4><p>z1中的数据：</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504201631166.png" alt=""></p>
<p>分页查询发现m6被查询了两次：</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504201631407.png" alt=""></p>
<p>解决办法：<code>ZREVRANGEBYSCORE z1 6 0 withscores limit 2 3</code></p>
<p>滚动分页查询参数：</p>
<ul>
<li>max：当前时间戳 | 上一次查询的最小值</li>
<li>min：0</li>
<li>offset：0 | 在上一次的结果中，与最小值一样的元素的个数（也就是说上次查询了的下一次查询不要反复出现，要跳过）</li>
<li>count：每一页数量</li>
</ul>
<h2 id="附近商铺"><a href="#附近商铺" class="headerlink" title="附近商铺"></a>附近商铺</h2><h3 id="GEO数据结构"><a href="#GEO数据结构" class="headerlink" title="GEO数据结构"></a>GEO数据结构</h3><p>GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。常见的命令有：</p>
<ul>
<li>GEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）</li>
<li>GEODIST：计算指定的两个点之间的距离并返回</li>
<li>GEOHASH：将指定member的坐标转为hash字符串形式并返回</li>
<li>GEOPOS：返回指定member的坐标</li>
<li>GEORADIUS：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。6.以后已废弃</li>
<li>GEOSEARCH：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。6.2.新功能</li>
<li>GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key。 6.2.新功能</li>
</ul>
<h3 id="附近商户搜索"><a href="#附近商户搜索" class="headerlink" title="附近商户搜索"></a>附近商户搜索</h3><p>按照商户类型做分组，类型相同的商户作为同一组，以typeId为key存入同一个GEO集合中即可。</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504232147203.png" alt=""></p>
<h2 id="用户签到"><a href="#用户签到" class="headerlink" title="用户签到"></a>用户签到</h2><h3 id="BitMap用法"><a href="#BitMap用法" class="headerlink" title="BitMap用法"></a>BitMap用法</h3><p>存在问题：</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504242122992.png" alt=""></p>
<p>解决：</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504242124542.png" alt=""></p>
<p>BitMap的操作命令有：</p>
<ul>
<li><code>SETBIT</code>:向指定位置(offset)存入一个0或1</li>
<li><code>GETBIT</code>:获取指定位置（offset)的bit值</li>
<li><code>BITCOUNT</code>:统计BitMap中值为1的bit位的数量</li>
<li><code>BITFIELD</code>:操作（查询、修改、自增)BitMap中bit数组中的指定位置（offset)的值</li>
<li><code>BITFIELD_RO</code>:获取BitMap中bit数组，并以十进制形式返回</li>
<li><code>BITOP</code>:将多个BitMap的结果做位运算（与、或、异或）</li>
<li><code>BITPOS</code>：查找bit数组中指定范围内第一个0或1出现的位置</li>
</ul>
<h3 id="签到功能"><a href="#签到功能" class="headerlink" title="签到功能"></a>签到功能</h3><p>需求：实现签到接口，将当前用户当天签到信息保存到Redis中</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>请求方式</td>
<td>Post</td>
</tr>
<tr>
<td>请求路径</td>
<td>/user/sign</td>
</tr>
<tr>
<td>请求参数</td>
<td>无</td>
</tr>
<tr>
<td>返回值</td>
<td>无</td>
</tr>
</tbody>
</table>
</div>
<p>提示：因为BitMap底层是基于String数据结构，因此其操作也都封装在字符串相关操作中了。</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504242149847.png" alt=""></p>
<h3 id="签到统计"><a href="#签到统计" class="headerlink" title="签到统计"></a>签到统计</h3><p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504242219926.png" alt=""></p>
<p>需求：实现下面接口，统计当前用户截止当前时间在本月的连续签到天数</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>请求方式</td>
<td>GET</td>
</tr>
<tr>
<td>请求路径</td>
<td>/user/sign/count</td>
</tr>
<tr>
<td>请求参数</td>
<td>无</td>
</tr>
<tr>
<td>返回值</td>
<td>连续签到天数</td>
</tr>
</tbody>
</table>
</div>
<h2 id="UV统计"><a href="#UV统计" class="headerlink" title="UV统计"></a>UV统计</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>UV:全称Unique Visitor,也叫独立访客量，是指通过互联网访问、浏览这个网页的自然人。1天内同一个用户多次访问该网站，只记录1次。</li>
<li>PV:全称Page View,也叫页面访问量或点击量，用户每访问网站的一个页面，记录1次PV,用户多次打开页面，则记录多次PV。往往用来衡量网站的流量。</li>
</ul>
<p>UV统计在服务端做会比较麻烦，因为要判断该用户是否已经统计过了，需要将统计过的用户信息保存。但是如果每个访问的用户都保存到Redis中，数据量会非常恐怖。</p>
<p><strong>HyperLogLog：</strong></p>
<p>HyperLogLog(HLL)是从Logog算法派生的慨率算法，用于确定非常大的集合的基数，而不需要存储其所有值。相关算法原理大家可以参考：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903785744056333#heading-0">https://juejin.cn/post/6844903785744056333#heading-0</a></p>
<p>Redis中的HLL是基于string结构实现的，单个HLL的内存永远小于16kb,内存占用低的令人发指！作为代价，其测量结果是概率的，有小于0.81%的误差。不过对于UV统计来说，这完全可以忽略。</p>
<p><img src="https://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/202504251034256.png" alt=""></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://funnytorch.github.io">Torch</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://funnytorch.github.io/2025/03/12/redis-%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E5%AD%A6%E4%B9%A0/">https://funnytorch.github.io/2025/03/12/redis-%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E5%AD%A6%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://funnytorch.github.io" target="_blank">Torch's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/redis/">redis</a></div><div class="post_share"><div class="social-share" data-image="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farticle%2F214ebafad407d4879ef439b124f8d375969f7a68.jpg&amp;refer=http%3A%2F%2Fi0.hdslb.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1637623496&amp;t=e16f6f4016cd1ecf6cadb59f18d702fe" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://lib.baomitu.com/social-share.js/1.0.16/css/share.min.css" media="print" onload="this.media='all'"><script src="https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/04/07/2025-04-07-2025-04-13%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E5%91%A8%E6%8A%A5/" title="2025-04-07-2025-04-13论文阅读周报"><img class="cover" src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farchive%2F06212a062d0da00d93e03824ed971d2f5630c3b0.jpg&amp;refer=http%3A%2F%2Fi0.hdslb.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1673181885&amp;t=1278ca088220515681ecb633cb8819b0" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">2025-04-07-2025-04-13论文阅读周报</div></div></a></div><div class="next-post pull-right"><a href="/2025/03/07/System-out%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%9F/" title="System.out为什么是一个对象？"><img class="cover" src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic_source%2Fe2%2Fbb%2F96%2Fe2bb96f4f5a3d5618c6481a3044f8917.jpg&amp;refer=http%3A%2F%2Fup.enterdesk.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1650166003&amp;t=c6ec692477d4a86affe587a77ecc567d" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">System.out为什么是一个对象？</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://pic1.imgdb.cn/item/646c2881e03e90d874adf7fc.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Torch</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">87</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">60</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/funnytorch"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/funnytorch" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:torch2147483647@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog<div class="xpand" style="height:200px;"><canvas class="illo" width="800" height="800" style="max-width: 200px; max-height: 200px; touch-action: none; width: 640px; height: 640px;"></canvas></div></div><script src="https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/twopeople1.js"></script><script src="https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/zdog.dist.js"></script><script id="rendered-js" src="https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/twopeople.js"></script><style>.card-widget.card-announcement {
margin: 0;
align-items: center;
justify-content: center;
text-align: center;
}
canvas {
display: block;
margin: 0 auto;
cursor: move;
}</style></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">基础篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E8%AF%86Redis"><span class="toc-number">1.1.</span> <span class="toc-text">初识Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NoSQL"><span class="toc-number">1.1.1.</span> <span class="toc-text">NoSQL</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E4%B8%8E%E9%9D%9E%E7%BB%93%E6%9E%84%E5%8C%96"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">结构化与非结构化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E4%B8%8E%E9%9D%9E%E5%85%B3%E8%81%94"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">关联与非关联</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">查询方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.1.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86Redis"><span class="toc-number">1.1.2.</span> <span class="toc-text">认识Redis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85Redis"><span class="toc-number">1.1.3.</span> <span class="toc-text">安装Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">Redis安装说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E6%9C%BA%E5%AE%89%E8%A3%85Redis"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">单机安装Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A41-%E5%AE%89%E8%A3%85Redis%E4%BE%9D%E8%B5%96"><span class="toc-number">1.1.3.2.1.</span> <span class="toc-text">步骤1.安装Redis依赖</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A42-%E4%B8%8A%E4%BC%A0%E5%AE%89%E8%A3%85%E5%8C%85%E5%B9%B6%E8%A7%A3%E5%8E%8B"><span class="toc-number">1.1.3.2.2.</span> <span class="toc-text">步骤2.上传安装包并解压</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A43-%E5%90%AF%E5%8A%A8"><span class="toc-number">1.1.3.2.3.</span> <span class="toc-text">步骤3.启动</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%90%AF%E5%8A%A8"><span class="toc-number">1.1.3.2.3.1.</span> <span class="toc-text">默认启动</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E9%85%8D%E7%BD%AE%E5%90%AF%E5%8A%A8"><span class="toc-number">1.1.3.2.3.2.</span> <span class="toc-text">指定配置启动</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF"><span class="toc-number">1.1.3.2.3.3.</span> <span class="toc-text">开机自启</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">Redis命令行客户端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E5%BD%A2%E5%8C%96%E6%A1%8C%E9%9D%A2%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">图形化桌面客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.1.3.4.1.</span> <span class="toc-text">建立连接</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.</span> <span class="toc-text">Redis命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.1.</span> <span class="toc-text">数据结构介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.2.</span> <span class="toc-text">通用命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%BB%A5a%E5%BC%80%E5%A4%B4%E7%9A%84key"><span class="toc-number">2.</span> <span class="toc-text">查询以a开头的key</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E5%91%BD%E4%BB%A4"><span class="toc-number">2.0.1.</span> <span class="toc-text">String命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Key%E7%9A%84%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84"><span class="toc-number">2.0.2.</span> <span class="toc-text">Key的层级结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash%E5%91%BD%E4%BB%A4"><span class="toc-number">2.0.3.</span> <span class="toc-text">Hash命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set%E5%91%BD%E4%BB%A4"><span class="toc-number">2.0.4.</span> <span class="toc-text">Set命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SortedSet%E5%91%BD%E4%BB%A4"><span class="toc-number">2.0.5.</span> <span class="toc-text">SortedSet命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9A%84Java%E5%AE%A2%E6%88%B7%E7%AB%AF-Jedis"><span class="toc-number">2.1.</span> <span class="toc-text">Redis的Java客户端-Jedis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">2.1.1.</span> <span class="toc-text">快速入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Jedis%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-number">2.1.2.</span> <span class="toc-text">Jedis连接池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9A%84Java%E5%AE%A2%E6%88%B7%E7%AB%AF-SpringDataRedis"><span class="toc-number">2.2.</span> <span class="toc-text">Redis的Java客户端-SpringDataRedis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-1"><span class="toc-number">2.2.0.1.</span> <span class="toc-text">快速入门</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8"><span class="toc-number">2.2.0.2.</span> <span class="toc-text">数据序列化器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StringRedisTemplate"><span class="toc-number">2.2.0.3.</span> <span class="toc-text">StringRedisTemplate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hash%E7%BB%93%E6%9E%84%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.0.4.</span> <span class="toc-text">Hash结构操作</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E7%AF%87"><span class="toc-number">3.</span> <span class="toc-text">实战篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95"><span class="toc-number">3.1.</span> <span class="toc-text">短信登录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%95%86%E6%88%B7%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.2.</span> <span class="toc-text">商户查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98"><span class="toc-number">3.2.1.</span> <span class="toc-text">什么是缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="toc-number">3.2.2.</span> <span class="toc-text">缓存更新策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">3.2.2.1.</span> <span class="toc-text"> </span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%88%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%EF%BC%8C%E5%86%8D%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">3.2.2.1.1.</span> <span class="toc-text">先删除缓存，再操作数据库</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%88%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E5%86%8D%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98"><span class="toc-number">3.2.2.1.2.</span> <span class="toc-text">先操作数据库，再删除缓存</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">缓存更新策略的最佳实践</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">3.2.3.</span> <span class="toc-text">缓存穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%95%86%E9%93%BA%E6%9F%A5%E8%AF%A2%E7%9A%84%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">解决商铺查询的缓存穿透问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">3.2.4.</span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">3.2.5.</span> <span class="toc-text">缓存击穿</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E4%BA%92%E6%96%A5%E9%94%81%E6%96%B9%E5%BC%8F%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98"><span class="toc-number">3.2.5.1.</span> <span class="toc-text">基于互斥锁方式解决缓存击穿问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F%E6%96%B9%E5%BC%8F%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98"><span class="toc-number">3.2.5.2.</span> <span class="toc-text">基于逻辑过期方式解决缓存击穿问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%88important%EF%BC%89"><span class="toc-number">3.2.5.3.</span> <span class="toc-text">注意事项（important）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80"><span class="toc-number">3.3.</span> <span class="toc-text">优惠券秒杀</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80ID%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">3.3.1.</span> <span class="toc-text">全局ID生成器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%A7%92%E6%9D%80%E4%B8%8B%E5%8D%95"><span class="toc-number">3.3.2.</span> <span class="toc-text">实现秒杀下单</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98"><span class="toc-number">3.3.3.</span> <span class="toc-text">超卖问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">3.3.3.1.</span> <span class="toc-text">悲观锁和乐观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">3.3.3.1.1.</span> <span class="toc-text">乐观锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E8%A7%A3%E5%86%B3%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98"><span class="toc-number">3.3.3.1.2.</span> <span class="toc-text">乐观锁解决超卖问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">3.3.3.1.3.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%BA%E4%B8%80%E5%8D%95"><span class="toc-number">3.3.4.</span> <span class="toc-text">一人一单</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">3.3.4.1.</span> <span class="toc-text">并发安全问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">3.4.</span> <span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ERedis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">3.4.1.</span> <span class="toc-text">基于Redis的分布式锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%88%86%E5%B8%83%E5%BC%8F%E8%AF%AF%E5%88%A0%E9%97%AE%E9%A2%98"><span class="toc-number">3.4.2.</span> <span class="toc-text">Redis分布式误删问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">3.4.3.</span> <span class="toc-text">分布式锁的原子性问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">3.4.4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redisson"><span class="toc-number">3.4.5.</span> <span class="toc-text">Redisson</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ERedis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%BC%98%E5%8C%96"><span class="toc-number">3.4.5.1.</span> <span class="toc-text">基于Redis的分布式锁优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.4.5.2.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A5%E9%97%A8"><span class="toc-number">3.4.5.3.</span> <span class="toc-text">入门</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redisson%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%8E%9F%E7%90%86"><span class="toc-number">3.4.5.4.</span> <span class="toc-text">Redisson可重入锁原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redisson%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86"><span class="toc-number">3.4.5.5.</span> <span class="toc-text">Redisson分布式锁原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E8%BF%BD%E6%BA%AF%EF%BC%88%E7%9C%8B%E9%97%A8%E7%8B%97%EF%BC%89"><span class="toc-number">3.4.5.5.1.</span> <span class="toc-text">源码追溯（看门狗）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#tryLock-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">3.4.5.5.1.1.</span> <span class="toc-text">tryLock()源码解析</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#unlock-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">3.4.5.5.1.2.</span> <span class="toc-text">unlock()源码解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redisson%E7%9A%84multiLock%E5%8E%9F%E7%90%86"><span class="toc-number">3.4.5.6.</span> <span class="toc-text">Redisson的multiLock原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E6%BA%AF%E6%BA%90"><span class="toc-number">3.4.5.6.1.</span> <span class="toc-text">源码溯源</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">3.4.5.7.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%92%E6%9D%80%E4%BC%98%E5%8C%96"><span class="toc-number">3.5.</span> <span class="toc-text">秒杀优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%A7%92%E6%9D%80"><span class="toc-number">3.5.1.</span> <span class="toc-text">异步秒杀</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redis%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.5.1.1.</span> <span class="toc-text">redis存储结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ERedis%E5%AE%9E%E7%8E%B0%E7%A7%92%E6%9D%80%E8%B5%84%E6%A0%BC%E5%88%A4%E6%96%AD"><span class="toc-number">3.5.2.</span> <span class="toc-text">基于Redis实现秒杀资格判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-number">3.5.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">3.6.</span> <span class="toc-text">Redis消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">3.6.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EList%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">3.6.2.</span> <span class="toc-text">基于List结构模拟消息队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EPubSub%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">3.6.3.</span> <span class="toc-text">基于PubSub的消息队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EStream%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">3.6.4.</span> <span class="toc-text">基于Stream的消息队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stream%E7%9A%84%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.6.5.</span> <span class="toc-text">Stream的消费者组模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-6"><span class="toc-number">3.6.6.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EStream%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%A7%92%E6%9D%80"><span class="toc-number">3.6.7.</span> <span class="toc-text">基于Stream消息队列实现异步秒杀</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%BE%E4%BA%BA%E6%8E%A2%E5%BA%97"><span class="toc-number">3.7.</span> <span class="toc-text">达人探店</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A5%BD%E5%8F%8B%E5%85%B3%E6%B3%A8"><span class="toc-number">3.8.</span> <span class="toc-text">好友关注</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E6%B3%A8%E5%92%8C%E5%8F%96%E5%85%B3"><span class="toc-number">3.8.1.</span> <span class="toc-text">关注和取关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E5%90%8C%E5%85%B3%E6%B3%A8"><span class="toc-number">3.8.2.</span> <span class="toc-text">共同关注</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E6%B3%A8%E6%8E%A8%E9%80%81"><span class="toc-number">3.8.3.</span> <span class="toc-text">关注推送</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-1"><span class="toc-number">3.8.4.</span> <span class="toc-text"> </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%8E%A8%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%85%B3%E6%B3%A8%E6%8E%A8%E9%80%81%E5%8A%9F%E8%83%BD"><span class="toc-number">3.8.5.</span> <span class="toc-text">基于推模式实现关注推送功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Feed%E6%B5%81%E7%9A%84%E5%88%86%E9%A1%B5%E9%97%AE%E9%A2%98"><span class="toc-number">3.8.5.1.</span> <span class="toc-text">Feed流的分页问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%85%B3%E6%B3%A8%E6%8E%A8%E9%80%81%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.8.6.</span> <span class="toc-text">实现关注推送页面的分页查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%9A%E5%8A%A8%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98"><span class="toc-number">3.8.6.1.</span> <span class="toc-text">滚动分页查询存在问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E8%BF%91%E5%95%86%E9%93%BA"><span class="toc-number">3.9.</span> <span class="toc-text">附近商铺</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GEO%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.9.1.</span> <span class="toc-text">GEO数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%84%E8%BF%91%E5%95%86%E6%88%B7%E6%90%9C%E7%B4%A2"><span class="toc-number">3.9.2.</span> <span class="toc-text">附近商户搜索</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%AD%BE%E5%88%B0"><span class="toc-number">3.10.</span> <span class="toc-text">用户签到</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BitMap%E7%94%A8%E6%B3%95"><span class="toc-number">3.10.1.</span> <span class="toc-text">BitMap用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%BE%E5%88%B0%E5%8A%9F%E8%83%BD"><span class="toc-number">3.10.2.</span> <span class="toc-text">签到功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%BE%E5%88%B0%E7%BB%9F%E8%AE%A1"><span class="toc-number">3.10.3.</span> <span class="toc-text">签到统计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UV%E7%BB%9F%E8%AE%A1"><span class="toc-number">3.11.</span> <span class="toc-text">UV统计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">3.11.1.</span> <span class="toc-text">概念</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/09/08/%E5%8A%9B%E6%89%A3hot100/" title="力扣hot100"><img src="https://pic.imgdb.cn/item/65d6d87d9f345e8d03134f04.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="力扣hot100"/></a><div class="content"><a class="title" href="/2025/09/08/%E5%8A%9B%E6%89%A3hot100/" title="力扣hot100">力扣hot100</a><time datetime="2025-09-08T03:44:23.000Z" title="发表于 2025-09-08 11:44:23">2025-09-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/01/2025-9%E6%9C%88%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" title="2025-9月论文阅读"><img src="https://pic.imgdb.cn/item/65d6d87d9f345e8d03134f04.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2025-9月论文阅读"/></a><div class="content"><a class="title" href="/2025/09/01/2025-9%E6%9C%88%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" title="2025-9月论文阅读">2025-9月论文阅读</a><time datetime="2025-09-01T02:24:47.000Z" title="发表于 2025-09-01 10:24:47">2025-09-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/27/2025-8%E6%9C%88%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" title="2025-8月论文阅读"><img src="https://pic.imgdb.cn/item/65d6d87d9f345e8d03134f04.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2025-8月论文阅读"/></a><div class="content"><a class="title" href="/2025/08/27/2025-8%E6%9C%88%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" title="2025-8月论文阅读">2025-8月论文阅读</a><time datetime="2025-08-27T02:17:30.000Z" title="发表于 2025-08-27 10:17:30">2025-08-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/17/%E9%BB%91%E9%A9%AC%E5%85%AB%E8%82%A1%E5%AD%A6%E4%B9%A0/" title="黑马八股学习"><img src="https://pic.imgdb.cn/item/65d6d87d9f345e8d03134f04.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="黑马八股学习"/></a><div class="content"><a class="title" href="/2025/08/17/%E9%BB%91%E9%A9%AC%E5%85%AB%E8%82%A1%E5%AD%A6%E4%B9%A0/" title="黑马八股学习">黑马八股学习</a><time datetime="2025-08-17T07:37:35.000Z" title="发表于 2025-08-17 15:37:35">2025-08-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/08/2025-7%E6%9C%88%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" title="2025-7月论文阅读"><img src="https://pic.imgdb.cn/item/65d6d87d9f345e8d03134f04.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2025-7月论文阅读"/></a><div class="content"><a class="title" href="/2025/07/08/2025-7%E6%9C%88%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" title="2025-7月论文阅读">2025-7月论文阅读</a><time datetime="2025-07-08T08:24:55.000Z" title="发表于 2025-07-08 16:24:55">2025-07-08</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>再看看那个光点，它就在这里，这是家园，这是我们 —— 你所爱的每一个人，你认识的一个人，你听说过的每一个人，曾经有过的每一个人，都在它上面度过他们的一生✨</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://stellarium.org/">点击开启星辰之旅</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/about/">关于作者</a><a href="/comments/">留点什么</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li><li><a href="/archives/">文章归档</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"></div></div></div><div class="copyright"><span><b>&copy;2020 - 2025</b></span><span><b>&nbsp;&nbsp;By Torch</b></span></div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo"><img src="https://img.shields.io/badge/Frame-Hexo-blue?logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly"><img src="https://img.shields.io/badge/Theme-Butterfly-purple?logo=bitcoin" alt=""/></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20226665" style="margin-inline:5px" title="本站已加入萌ICP豪华套餐，萌ICP备20226665号"><img src="https://sourcebucket.s3.ladydaily.com/badge/萌ICP备-20226665-fe1384.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://cn.aliyun.com/" style="margin-inline:5px" title="本网站大部分图片在阿里云对象存储"><img src="https://img.shields.io/badge/Bucket-%E9%98%BF%E9%87%8C%E4%BA%91-orange?logo=academia" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本网站源码由Github提供存储仓库"><img src="https://img.shields.io/badge/Source-Github-black?logo=github" alt=""/></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20240421" style="margin-inline:5px" title="本站已加入萌ICP豪华套餐，萌ICP备20240421号"><img src="https://img.shields.io/badge/%E8%90%8CICP%E5%A4%87-20240421-F2218A?logo=data%3Aimage%2Fpng%3Bbase64%2CiVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAARzQklUCAgICHwIZIgAABHOSURBVHic7ZtpmFTF1cd%2FdXuf6VmYnhlAdiQsGkEWAQEVNb4KGsW8btGAxo1FFAIuBAyLa1BQUFGRqCB5RY3mSWIUI0beyCaLgKjI4gayjszWPT3T6618OLfn9gzTyMCgXzzP00%2FfW1Vd95z%2FPVudqoaf6Cf6iX4M0lo79P%2Fvv09vLL1fa%2B34sfhw%2FtAP1Fo7uHf1dJo9kk9F6U2goUXLfP3g2kom952mlEr%2BkPyoH%2BIhWmtlzv9slvHEyuZs%2FdLA5R5GtseHw5ABCRPC0RoS8b%2BZvbuYxvhBB%2FlN5zuVUvpE83bCANBaK5bufdR8%2FINWxrJPweBi%2FJ4cXA5QKjXI4iLtPpaAUDQEjre4rCdMHLSPs4pPGBhNDoD%2BtPI%2Bc87KLsaijyBecxHZ7ly8LutpSoQ0NVTHIJqQdq8LfC4wlD1GA5E4VEeD%2BHLe4Za%2BmOPP2u3o6L2rKfltMgCS01fPMOatPoXvDg7G6ys8XCANkQRUR9HZOaiRA9B3D0JVJ9AzP0C9sBbi1ZDtITNgkUratllmjh2w1XF3n2lNwfdxAaBf%2BHwqT67qwaYd4HSdhd9ThMM4XKWrYqANuKIPjD8TPbAYhbzkdAb0u3tRc1fD25vBQMBw1zOZRBKqYt%2BRTKzQA09F3T7wY3XNyfcdqwyNBkC%2Ft28cc1cP5s2PQDEAv6cYt%2FNwJqvjEI9D%2F1Pg9n5wbRdb4J1hmLsG5q0Evxs9eiBq3JnQyi1TAOpPW%2BHJ1bBlJ7jdkOXmMHCjCaiKlIBztb66L%2BqO%2Fh%2BpgcUPNDkA%2BovqsfrxlReoBWshFu5JlqcNXpf8Ol1Na2IQiUKrVujb%2B6PG9wWPNUkUmLse5q6CfQfAcECXIthZKqYSi8HJbWD8IPTYHrXM6QoNj61GzVsNZYfA5xV%2FoeqZV00camIHycldy%2BgB%2F1aPDH7iuAHQL24dw6R3hnLwwGl4PW3xuTM5KvBmw0390BPOgo5eW8Vf3oF%2BfBVqwzZwWW9SKaioAv1HGPZ%2FsHQH5LghnoRwDJIJOOc09PgBqGEdhBeAT4Lw2ErU4vWQjEK2uwF%2FYUJ17FuisS20bQNP%2FHKpGtZ%2B3rEBkDvzGczqUXhch9t1OAamQl%2FaEzV%2BAJzb0mZ05UHUnDXwxkZQSfC7wW3lXKVhwICnfwmj%2B0FlBNo8AqFqyMsGlyNNvaNguOG6vjC%2BP%2FQqqDUj%2Fc%2FdqLmr4L0t4HAIGPVDbHUU2rWer7aNHHVsADD5GQJZo2rRDUUgFkP37Iy6YyD6hq61E%2BhdNai5a2HBGqgKQpYHvE5bVQEOheG7yVCY3fADT5kL%2B4IiSEqIWvWOQkEARg9EjzsDVeSyAX96C%2BrJNbDtK%2FB6BQylRBvCzFfRPzQeAP1F9V10um8iAX9zAEIR9F1DUJMGoP21CMGcjahp70HoIHiyRcWNNKHTKZqAkwtg09jD%2B55dB6P%2FAQFfw7%2FVGpKmhMNYHN2tPWrcIPTIn9svoSSBmr4cFq4UPgBKQ%2FMVMzMCYGTqYHtJezCa1779uAP1wADwg3r9S9SgxSjjHtSEl2DDjXBZLzAzzibkccLm%2FTBlWd32kjCMfiWz8CDtTgfkeMHnRX2%2BG8YsQanfw4WvwNI9UOxEP32BaEvqN3C53lw2qfEAfFMOTosZU0OLPAD0W7vgyqdgw07pCxRB50J449fQKhdiSYibdppbnxwGdGxWt604G3BlZAWQ9UJ5DZSGYEhnKJkifAX8sGobDH0UtlSINrj9aWm2o9j8urxtowEwvw2CYXUnTWhdIPPtqQS80LcNfD0JDk2xBfv6TqiaJgIlMwCgEB%2Fw0iZwT4URr4tpeLxHFr6FH16%2BCuZcCm9cC0XZQAwqo1Yk8Fu8AYU5Ak6Kr92VGafOuBw29lWBI00Dii3HdaAKnE74aF%2FD6jr5XfiqHAp8DU%2Bc74MrXpZrvwde%2FxQWb4RAdmb1dyjYfgiuOq1uu54Fs1bAve%2BBQ6H3BiVCtMhGfWEJbSiM76oyiXkEEyivEmcGYGp0sQikS6rAaYDHAe0byEAfXg55nsPb0ynfJx%2BnIR670J9ZeJA%2BtwOufe3wvlyvvCBDoUrCMrwwRyIAiAyHqjNOnRmAYMRmytSoPAFAVVRLu8Ogjt2W1cj30G7iA5qa4kkY1q1u221vwsjXIc8rglZEpD3HYztkBQQTGafNXBGqTthBUgM%2BK6xUJW3YDDes%2FAb%2BdwmUlMKlp8PBKtt5NiVpoFMAHlslWjPyDPj0APgt01Sqdnmt%2FU5UWq3BrM5sApkBqF%2BYSgkVT3NuBT4453lJYwPN4P2vZJzzBJT4AlnQ52nxB4k4rP0WdlWAK02JLd5UepsCzMyKnhmAw16ibrg93dl5T3CJMZBlseKFVz8RP%2BSoJyygta7HZuYyY2aOnfUmjlvXblWLxY9GSkFWvbxBa3CltDS9HXBlzjEyA%2BB32YIqhQ7XCKq5bjvJCEUlR8hvIOTFkhCsgYJsO5rUp0hC6gam9YZSixp3AyYUikI0mkEKl5iGT6KPCkbtZ2qN4c%2FKKGZmAPJ8djKhQJXJw3WBH2VqYejus%2BC05nD1q7Z6poTvWADv3witZtr1vhSZGspCMOhkGNsferWEhIb1e2DmCth6oG5eEIrCXWfB%2Fb9omNclH8O1f4YCAUBX1KBqIxiQm9knZQTALM7CSM%2BmSsSTqpZZIkA8Ab%2FtDR2awfDXRRNS9hiKwtRzoZkPep8EHx%2BQdQBIfC4Lw39Gwtkd6j60WxGM6AmLN8GIVyCQa3n3JAxuL2O%2BrbQSNEvALJcV%2FjScJOk6B9NzGBMKcxsPAK2biVAgk%2B0JAqBb5aGSGjChtfXAG3vDix9JZqc16CRcfor0dSyQrNGD9JWFYOtE6FYMH%2B%2BH6%2F4Cn%2B0Vgfq1h79eB8N7SoIzbBEEcmSeqGUmbe9D8o80jXK5ADe0E0HVgZCdxSY1tPOTiTLHh%2Fb5dj7vMGB3qVx3LbZs1mGHoFF9IRKT60gCLk5LWH4WkFwepDg64RwR%2Fp0dcPos2F0hbzqQA58ehFYzYMchuKwbDD1F5ksntx8KciTfT31yPfJCfhYQt1VeKesYDZhmjPZFkUYDYHQtimAmRSpDQVg0QHUvAJKy8gMIRqF7C8jxicaEYzCmnz1R5yJbk6IRmD1Uroc8DwUFYhqpoonPBXl50PMpGfPoRRCu5%2FjiSfExsYT9SZqAC1q4Ufvj2GFAA%2BafOaf57xsNAL0LJoNejNa2M9pcJtrnzJGsDODOpfJ9Ux8IxwEThnYRO%2F6qDLoWih0mTGhhLYOf3wDK1XB0cDmklLXiGzilWMBOj7udC6WocnJAPp0Lpb2d1G30xn2grNKYBnDFlVIZwscRAFBKRcnKj9dGAqcTvXq3XPdoDe0s%2B3%2F1E6nd3d4fYlVwRXdpX7BBlqFdCgUUU0NLy54%2F%2F84uezXIlRO%2BsEwuL6cuANvGw%2BaxsPE2%2BawfA%2BV%2FEDAAtXqXPXcyCe1bZH4O37c73LsVbPpKfIDbgVr%2BNYw5HQZ3AI9l88EgPL1OQiJuuOUMaV%2BxFXb1kbEgPqva%2Bk0gyw6xDZFpygIHoLKGOg5vzmrxPSmtdDvg7e1w%2Balyv%2FwbyRBBTOXMtvDNMQJgnt8RY%2B1OKTh4HPCuVQUa2hl2fGuN0rBgvQBwaz%2F4n07w1nbAYb%2FFolxZIW4%2FKPfX9oDJ%2FwTtOXwZrDUQg1%2BdKkkSybps%2Fu7vYKSZjwaSYXjuGqkYr9kJBRZ40USUc9tXsySzjJl9AGBc3LWSWCyM1uJVg4dgfwLOOwkGdIIDIcAFXxyEsmqYP0x%2B%2BOw6UF7Y9p3cnxwQR2U44bVPoF0%2BXNVbSuTppTOtoTQIM4bI%2FawVsiuUTm6vXU%2FI90nJvWUbKHSg1pYCCQFHazBjL3PLafccUcYjddInMAXcS2odocsjpSyA7gEJWxjS%2Fsw6%2B3f%2F%2FEwY23FI7js2EyeY54Ub3pC2V6%2BBEb2gtELK5YfCcn3vBTD1PAl%2F05ZJbpFOsRqpPZRVy6cyCMP7SN%2BfN4HXAixpQl5hQikV5wh0RBNQSiX1kNdMPvhM6gFZLpi%2FFu6x7HxHqSyaslxiBlMGw5vbZFqXIf0gjjCVKRoKOj8GOybAoitEa5bukPGXdLUfftIfITfLVvVUYrPwGmsDxBoXScBl3UX9F66XUJpqH94PFhxJwqM5InNz73KWbqrC5%2FbjdMDXe%2BDrKHTwwKZ9AoDTgL0hmPQvWLIF8r2iMRGrFNU6z3bkPhfsC0HWdHj%2Bcvh1DztrBJj3IYx9UzLB1KLIoSSJAri%2BV4NsqhUlsiETsCrCkUiYm3uVfx8A31u60VobqKkLKHDfiGFIYnJlP1g0FP3UFtTtr0hNT2txWh6nvZROmlIjqIiIlqQ7vKQpFV0zBs1yxElWhcHpFuHTcwStJeFqnQuxtHJbSQj%2BfisMaYM%2Bfwlq7XbR1EQStPtFKu65WSl1xPrckX0AoJQyuWngIcLRECAPeGmV9I3tLpuiyaQIl%2B2uW0dwGKKK9YVP9RX4JA0GMYFArji2%2BgmSUpLultdIphmOQUW1ZJJD2kBJAvX%2Bx%2FZGaVWsigmDD32f8EcFAAB%2FunAS0egbEg2UhMSx70vfC1dDeT1vXl%2FQ76v4OoyjG%2Bd0CMAOBeFqeP066bvlTdmLTO1iJZJvMLXfEb1%2Fio4KAKWU5tyeJURiogV%2BD8x7F0LArztBtw72eZ8fgqpjcF5PGFQshy3%2BsSataBsJMWJQydEeqjrq8q3WWqHuXkggb4Q4uBi6WzvUut%2BigxqVNwUKsuzdpBNFSRMqEmhzujDf%2FkkoL5ftd62hNLwY%2FdD1RwvAUXOrlNLmVYN2EYqWAeBxodZvR7%2BwDZWr0K%2FeBGXBzKbQFKQ1lAdh1VgRfvoa2L3fPntQURM0J160qzFH6hpdwNfc%2BxIFnuEYhlXaCqMPzIDmLtTED%2BCxt2VtfyR7PhbSGkor0HOHo%2B7oDlsqocdDdtUokYSo8ZaqufeSxkzbeH39y43fUBasrHWIeV5Up1nSN%2Fts9PWDZAe3KTXBEp7JvxLhI0CP2RI%2BU46vIlhpLh%2F1RWOnbjQA6sqOU7m0%2F4tU1lQA4HKCjqJazZH%2BhZfAhKFQWmnvzx0PJU0R%2FrHfwINnyo5X8cOQ65TIIXZfwdghCx39C8c3Wp5j5Uu3fHwOoYrr8brzASli5DeDvRYPr30JVz8vESNV9WnUA6yjMdVJWD4WBjeHKOjih1FmzI75oWgFXVovUltubbTwcLwHJZ0z5pDFDbidUh2piQFu2HkXtHRBhQl958POXdDMX3cXJ%2BOk1lGYiio4oxt8eIPo6WchOG0W5DhspxeJVuLOXqTK7hl3rDIcV8xSiWnjCSYWEUvIZrzPDc4EnDQVFmyFfAN2jEYvvAFCVjk8kWzYP6QOWJaG0QkH%2Bm9jYN0NaAN4aD38%2FAHId9YVPul56XiEhyY6K6y99z2II3krXlehnM6S8rfu3Rm1%2FEawKmHM2QxT34FQpRyD9bgAbZ81LCpCz7wYfmudPtsThfNegJ27ZZGTcnjhSCnZOc%2Bp0nsmHy%2FvTRardIcnHmTX%2FpE0yw7UMhpNQFUNjLoAnjlfxgEs24uauwbe2gw40Ff2gt8NgDOLhKkw6JvfRL2yEnKyLKCwHF5VKb1%2BNl9tvGlKU%2FDdpME6OfztB4zFy0fRLCeAI%2B2sX1VUNjZGDETffz6qbcMnSPTnIbj336i%2Ffij7fKlTpSDmUREMMvHSp9Tss5tEeGhiAAD0vw88wJD5XUnGLiDfl1v35GYMaqLoTm1RY%2Fqhb%2BkNNUnUcxvg2Q9hz37ISjsLDBJKy2uC5OYs4z9jdqvT8yY0Jb8n4CiH9ReZce%2FPNp5Y1hqP60L8nrpAxK3T5AlrAeVyytt2GnUPQIeiQeLmv5j%2Byz1M6z%2FxRPxr5IQAkCKttWLE27NZvOIknI6h%2BD05hx15h7r3SROCkRCmepvbBu%2FnqV9MOJH%2FHTqhAKRIa63MGR%2FONh7%2FoAWVpZfg9ebgc9Y9h1gTh2ikhubN%2F85d5%2B5nYq8T8sbr0w8CQIq01op1h2abz28oMl752CBYdjGYb1HY0uTa0zFv7VNpnJo77of%2B69yPQlprh%2F6yatKP%2BafJn%2Bgn%2Bon4L4cd%2F2hQhc%2BBAAAAAElFTkSuQmCC" alt=""/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.19/fancybox/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script async src="/js/title.js"></script><script defer src="/js/runtime.js"></script><script src="/js/sun_moon.js" async></script><script async src="/js/fps.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/fireworks.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = '0671ba19028145b2a6a05408f0b01332';
  var gaud_map_key = 'b5a4cd020508da8ff9992038833bd1ba';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '112.982279,28.19409';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><!-- hexo injector body_end end --></body></html>